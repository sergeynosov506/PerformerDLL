	/* 
* SUB-SYSTEM: Database Input/Output for CompositeMerge
* 
* FILENAME: CompositeMergeIO.cpp
* 
* DESCRIPTION:	This is set of classes/routines to access data in SQL Server database
*				used by Performance DLL. It was developed to replace Delphi's
*				written STARSIO.DLL to avoid usage of BDE-ODBC automatically created 
*				multiply connections and use single connection for all IO operations based on
*				OLE DB specs instead (MS OLE DB Provider for MS SQL Server). 
* 
* PUBLIC FUNCTION(S): see STARSIO specifications    
* 
* NOTES:  
*        
* USAGE:	As a part of Performer. Performance.DLL should be modified to import functions from 
*			OLEDBIO.DLL instead if STARSIO.DLL. 
* 
* AUTHOR: Valeriy Yegorov. (C) 2001 Effron Enterprises, Inc. 
*
*
**/

// History.
//2021-06-01 J#PER11638 Broke out weighted fees out from weighted fees - mk.
//2021-04-28 J#PER11568 Fixed the weightings for fees for various ROR Types - yb.
//2020-11-09 J#PER11247 Change to NCF calculation- only include CN, not exclude from fees - yb.
//2020-05-11 J#PER10792 Fix for inserting into Monthsum - needed cum_cons column and in right order - yb.
//2020-04-17 J#PER10654 Added Net of ConsultingFees - yb.
// 2018-07-23 VI#61937 Additional fixes for non-default merge - set EffStart and EffEnd Dates in Merge_Compsegmap - yb.
// 2018-07-20 VI#61937 Fix to non-default merge - was not using correct sessionid - yb.
// 2018-06-04 VI#61439 Undid Fix to left join to keep data the same until issue for partial period resolved - yb.
// 2018-05-24 VI#61439 Fix to left join - used same table in where nullifying left - yb.
// 2018-05-17 VI#61439 more updates for wtd avg merge for mid-period category changes - yb.
// 2018-05-11 VI#61439 more updates for wtd avg merge for mid-period category changes - yb.
// 2018-05-05 VI#61439 more updates for wtd avg merge for mid-period category changes - yb.
// 2018-04-26 VI#61439 more updates for wtd avg merge for mid-period category changes - yb.
// 2018-04-16 VI#61439 Update wtd avg merge to handle mid-period category changes - yb.
// 2017-05-08 VI#60053 Removed histassetcat.catindicator column -mk
// 2015-01-06 VI#56484 Fixed rounding of wtd flow, fixed SQL BuildSQLForCompositeEx - sergeyn
// 2014-07-01 VI#54971 More updates for handling IPVs and daily - yb.
// 2014-06-27 VI#54971 get inception records for segments - yb.
// 2014-06-27 VI#54971 More tweaks for mid-period inception, summing of data - yb.
// 2014-06-25 VI#54971 Fix when summing weighting factor when bmv is n/a - yb.
// 2014-06-23 VI#54971 Changed to used stored procs. Added getting records for each segment, not just one record per member - yb.
// 2014-03-18 VI#53709 Fix for cbyc only segments for total fund - yb.
// 2014-03-17 VI#53709 Update for alternate categories - yb.
// 2013-06-19 VI#52878 Fix to query for inceptionsummdata - yb.
// 2013-06-12 VI#52878 Added summing NotionalFlows - yb.
// 2013-04-16 VI#52266 Fixed setting last valid day of period - yb.
// 2013-02-22 VI#51605 Updated logic for pre/inception returns - yb.
// 2013-02-20 VI#51605 Updated to check if inception day returns needs to be calculated - yb.
// 2013-02-20 VI#51605 Delete out member returns that are calculated prior to composite inception - yb.
// 2012-12-12 VI#50551 If total weighting <0 and bmv <> 0 then multiply composite ror * -1 - yb.
// 2012-12-11 VI#50551 If total weighting <0 multiply composite ror * -1 - yb.
// 2012-11-29 VI#50551 additional fix if weighting factor is <0 and bmv =0 may be midmonth incept - yb.
// 2012-11-29 VI#50551 additional fix if weighting factor is <0 and bmv =0 may be midmonth incept - yb.
// 2012-11-28 VI#50551 additional fix if weighting factor is <0 and bmv =0 may be midmonth incept - yb.
// 2012-11-16 VI#50551 If the weighting factor is <0, multiple the member's return by -1.0 - yb.
// 2012-02-02 VI#47397 Set member BUV = 100.0 if BUV = -999 - yb.
// 2011-11-17 VI#46807 Do not reset actualdate on non-period end records to join on unit values - yb.
// 2011-10-18 VI#46807 Fix to setting mid period mvs to 0.0 - check other members of segment, not just member
//	          for values after ipv date - yb.
// 2011-09-15 VI#46525 Fix to stream begin date when acct incepted in prior month - yb.
// 2011-09-14 VI#46525 Additional fix to query for unit values - yb.
// 2011-09-12 VI#46525 Additional fix to query to eliminate some ror types for non-total fund - yb.
// 2011-09-12 VI#46525 Additional fix to query to eliminate some ror types for non-total fund - yb.
// 2011-09-09 VI#46525 Fix to query joining unitvalue to merge_uv to speed up - yb.
// 2011-08-16 VI#46525 re-arrangement of query order to get all ror types and stream begin dates - yb.
// 2011-08-12 VI#46525 Fix for setting beginning unit value when stream begin dae =  date from - yb.
// 2011-05-16 VI#46128 Fix for calcing a period with an ipv - only grab month prior's UV, not all prior to end date and upto begin date - yb.
// 2011-01-06 VI#45342 Added dated portcategory entries in Wtd Avg merge - mk.
// 2010-10-14 VI#45046 Fixed merge issues - mk.
// 2010-10-05 VI#45002 Ignore deleted portcategory entries - mk.
// 2008-12-11 Merge level 400 segments for category only composites also - yb.
// 2008-11-19 Various fixes for quarterly composites - yb.
// 2008-10-02 Fix to updating merge_uv for inception vs last month end - yb.
// 2008-09-05 Optimization of the buv queries - yb.
// 2008-08-20 Updated mergeuv for net vs gross for segments - yb
// 2008-06-10 Fix to parameters for updating inception weighted flows - wrong date used - yb.
// 2008-04-30 Fix to merging quarterly composites - put back beginning MV - yb
// 2008-04-24 Fix to merging quarterly composites - was including mvs from wrong date in total if member did 
//		not have an mv for end of period but had one for earlier in period - yb.
// 2008-04-23 Fix to reweighting flows dividing datediff() returns 0 as it does integer div. convert to float.
//				also fix to reweighting terminating member flows - yb.
// 2008-03-18 Fix for incepting accts - set buv to 100 (was taking inception day uv). 
//	          Fix for terminating accts - reweight flow for entire period (was setting to 0) - yb
// 08/06/2007 Fixed SQL for graceperiod dates to ignore the initialization record in
//				compport table - yb		
// 04/05/2007 Fixed SQL error in GetSummarizedDataForCompositeEx_SQL_013 - sergeyn
// 01/26/2007 Modified logic for incepting member weigting - now when WF is being 
//			  recalculated from NF, the Perform Type is also set to W. This indicates 
//			  later that if BMV+WF = 0 then instead of using NF as weight, now 0 will be 
//			  used (since we've already tried to determine correct WF, we don't want to 
//			  use NF anymore) - vay
// 10/26/2005 New query to write and delete to table: MapCompMemTransEx - ssi
// 05/25/2004 New query for composite membership (pending DB changes) - vay
// 11/29/2001 Partially implemented
// 09/10/2001 Started.

#include "commonheader.h"
#include "TransIO.h"
#include "OLEDBIOCommon.h"
#include "accdiv.h"
#include "divhist.h"
#include "contacts.h"
#include "ValuationIO.h"
#include "RollIO.h"
#include "summdata.h"
#include "unitvalu.h"
#include "MapCompMemTransEx.h"


//****************************************************************
// SelectAllMembersOfAComposite definitions
class CSelectAllMembersOfAComposite : public CQuery
{
public:
// data elements
	int			m_iID;
	int			m_iOwnerID;
	VARIANT		m_vDate;
	
// column binding map
BEGIN_COLUMN_MAP(CSelectAllMembersOfAComposite)
   COLUMN_ENTRY(1, m_iID)
END_COLUMN_MAP()

// parameter binding map
BEGIN_PARAM_MAP(CSelectAllMembersOfAComposite)
   COLUMN_ENTRY(1, m_iOwnerID)
   COLUMN_ENTRY(2, m_vDate)
END_PARAM_MAP()

DEFINE_COMMAND (CSelectAllMembersOfAComposite,	
/* obsolete			
				"SELECT distinct id FROM compport c1 \n\
				WHERE ownerid = ? \n\
				AND NOT EXISTS ( \n\
						SELECT id from compport c2 \n\
						WHERE c2.ownerid = c1.ownerid AND c2.id=c1.id \n\
						AND ( ?  BETWEEN \n\
						NULLIF(DateRangeBegin,''12/31/1899'') AND \n\
						ISNULL(NULLIF(DateRangeEnd, ''12/31/1899''),''9999-12-31'')))");
*/
/*	
	This is a query to determine composite membership 
	using new table structure (Oct 2004 release) - vay
*/
				"SELECT id FROM compport cp1 \n\
				WHERE ownerid = ? \n\
				AND included='Y' \n\
				AND DateRangeBegin = (SELECT MAX(DateRangeBegin) FROM compport cp2 \n\
                        WHERE cp2.ownerid = cp1.ownerid AND \n\
                              cp2.id = cp1.id  AND cp2.DateRangeBegin <= ? ) ");

};

CCommand<CAccessor<CSelectAllMembersOfAComposite>, CRowset > cmdSelectAllMembersOfAComposite;

ERRSTRUCT PrepareSelectAllMembersOfAComposite(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSelectAllMembersOfAComposite.m_bPrepared)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "PrepareSelectAllMembersOfAComposite", FALSE);
#endif

		try 
		{
			hr = cmdSelectAllMembersOfAComposite.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdSelectAllMembersOfAComposite.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2};
			DBPARAMBINDINFO	ParamInfo[2] = 
			{L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,			// ownerid
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0};	// input date	

			hr = cmdSelectAllMembersOfAComposite.SetParameterInfo(2, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";
		
			hr = cmdSelectAllMembersOfAComposite.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSelectAllMembersOfAComposite.m_vDate.vt = VT_DATE;
			cmdSelectAllMembersOfAComposite.m_cRows = 0;
			cmdSelectAllMembersOfAComposite.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSelectAllMembersOfAComposite.m_spCommand.p, sErr, hr, 
									"PrepareSelectAllMembersOfAComposite");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL SelectAllMembersOfAComposite(int iOwnerID, long lDate, int *piID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SelectAllMembersOfAComposite", FALSE);
#endif

	*pzErr = PrepareSelectAllMembersOfAComposite();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		// if subsequent call with previous params - get next record
		// if new params - close/open query
		if (!(cmdSelectAllMembersOfAComposite.m_iOwnerID == iOwnerID && 
			  cmdSelectAllMembersOfAComposite.m_vDate.date == lDate && 
			  cmdSelectAllMembersOfAComposite.m_cRows > 0))
		{
			cmdSelectAllMembersOfAComposite.m_cRows = 0;
			cmdSelectAllMembersOfAComposite.Close();

			cmdSelectAllMembersOfAComposite.m_iOwnerID = iOwnerID;
			SETVARDATE(cmdSelectAllMembersOfAComposite.m_vDate,lDate);

			hr = cmdSelectAllMembersOfAComposite.Open(&psClientRowset, NULL, true);
			if FAILED(hr) 
				throw "Open";
		}

		// before retrieving next row clear current buffer content
		cmdSelectAllMembersOfAComposite.m_iID = 0;

		// and get the record
		hr = cmdSelectAllMembersOfAComposite.MoveNext();
		if FAILED(hr) 
			throw "MoveNext";

		if (hr == S_OK) // got data - pass them back and exit
		{	
			cmdSelectAllMembersOfAComposite.m_cRows++;
			*piID = cmdSelectAllMembersOfAComposite.m_iID;
		}
		else // EOF reached
		{
			pzErr->iSqlError = SQLNOTFOUND;
			*piID = 0;
			cmdSelectAllMembersOfAComposite.m_cRows = 0; 
			cmdSelectAllMembersOfAComposite.Close();
		}

	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SelectAllMembersOfAComposite",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSelectAllMembersOfAComposite.m_spCommand.p, sErr, hr, 
								"SelectAllMembersOfAComposite");
	} // catch
}


DLLAPI void STDCALL SelectHoldingsFor(int iID, HOLDINGS *pzHoldings, char *TableName, ERRSTRUCT *pzErr)
{
	char sDLLHoldings[40];

	strcpy_s(sDLLHoldings, sHoldings); // Save Holdings table currently being used in DLL
	strcpy_s(sHoldings, TableName); // set Holdings_table_name internally used in the DLL 
	// call appopriate function from ValuationIO part
	SelectAllHoldingsForAnAccount(iID, pzHoldings, pzErr);
	strcpy_s(sHoldings, sDLLHoldings); // Set current table name back !
}


DLLAPI void STDCALL SelectHoldcashFor(int iID, HOLDCASH *pzHoldcash, char *TableName, ERRSTRUCT *pzErr)
{
	char sDLLHoldcash[40];

	strcpy_s(sDLLHoldcash, sHoldcash); // Save Holdcash table currently being used in DLL
	strcpy_s(sHoldcash, TableName); // set Holdcash_table_name internally used in the DLL 
	// call appopriate function from ValuationIO part
	SelectAllHoldcashForAnAccount(iID, pzHoldcash, pzErr);
	strcpy_s(sHoldcash, sDLLHoldcash); // Set current table name back !
}


//****************************************************************
// SelectTransFor definitions
class CSelectTransFor : public CQuery
{
public:
// data elements
	TRANS		m_zTrans;

	VARIANT		m_vTrdDate;
	VARIANT		m_vStlDate;
	VARIANT		m_vEffDate;
	VARIANT		m_vEntryDate;
	VARIANT		m_vOpenTrdDate;
	VARIANT		m_vOpenStlDate;
	VARIANT		m_vEffMatDate;
	VARIANT		m_vRollDate;
	VARIANT		m_vPerfDate;
	VARIANT		m_vCreateDate;
	VARIANT		m_vPostDate;

	int			m_iID;
	VARIANT		m_vInpEffDate1;
	VARIANT		m_vInpEffDate2;

// parameter binding map
BEGIN_PARAM_MAP(CSelectTransFor)
   COLUMN_ENTRY(1, m_iID)
   COLUMN_ENTRY(2, m_vInpEffDate1)
   COLUMN_ENTRY(3, m_vInpEffDate2)
END_PARAM_MAP()

// column binding map
BEGIN_COLUMN_MAP(CSelectTransFor)
   COLUMN_ENTRY(1,	m_zTrans.iID)
   COLUMN_ENTRY(2,	m_zTrans.lTransNo)
   COLUMN_ENTRY(3,	m_zTrans.sTranType)
   COLUMN_ENTRY(4,	m_zTrans.sSecNo)
   COLUMN_ENTRY(5,	m_zTrans.sWi)

   COLUMN_ENTRY(6,	m_zTrans.sSecXtend)
   COLUMN_ENTRY(7,	m_zTrans.sAcctType)
   COLUMN_ENTRY(8,	m_zTrans.iSecID)
   COLUMN_ENTRY(9,  m_zTrans.sSecSymbol)
   COLUMN_ENTRY(10, m_zTrans.fUnits)

   COLUMN_ENTRY(11,	m_zTrans.fOrigFace)
   COLUMN_ENTRY(12,	m_zTrans.fUnitCost)
   COLUMN_ENTRY(13,	m_zTrans.fTotCost)
   COLUMN_ENTRY(14,	m_zTrans.fOrigCost)

   COLUMN_ENTRY(15,	m_zTrans.fPcplAmt)
   COLUMN_ENTRY(16,	m_zTrans.fOptPrem)
   COLUMN_ENTRY(17,	m_zTrans.fAmortVal)
   COLUMN_ENTRY(18,	m_zTrans.fBasisAdj)

   COLUMN_ENTRY(19,	m_zTrans.fCommGcr)
   COLUMN_ENTRY(20,	m_zTrans.fNetComm)
   COLUMN_ENTRY(21,	m_zTrans.sCommCode)
   COLUMN_ENTRY(22,	m_zTrans.fSecFees)

   COLUMN_ENTRY(23,	m_zTrans.fMiscFee1)
   COLUMN_ENTRY(24,	m_zTrans.sFeeCode1)
   COLUMN_ENTRY(25,	m_zTrans.fMiscFee2)
   COLUMN_ENTRY(26,	m_zTrans.sFeeCode2)

   COLUMN_ENTRY(27,	m_zTrans.fAccrInt)
   COLUMN_ENTRY(28,	m_zTrans.fIncomeAmt)
   COLUMN_ENTRY(29,	m_zTrans.fNetFlow)
   COLUMN_ENTRY(30,	m_zTrans.sBrokerCode)

   COLUMN_ENTRY(31,	m_zTrans.sBrokerCode2)
   COLUMN_ENTRY(32,	m_vTrdDate)
   COLUMN_ENTRY(33,	m_vStlDate)
   COLUMN_ENTRY(34,	m_vEffDate)

   COLUMN_ENTRY(35,	m_vEntryDate)
   COLUMN_ENTRY(36,	m_zTrans.lTaxlotNo)
   COLUMN_ENTRY(37,	m_zTrans.lXrefTransNo)

   COLUMN_ENTRY(38,	m_zTrans.lPendDivNo)
   COLUMN_ENTRY(39,	m_zTrans.lRevTransNo)
   COLUMN_ENTRY(40,	m_zTrans.sRevType)

   COLUMN_ENTRY(41,	m_zTrans.lNewTransNo)
   COLUMN_ENTRY(42,	m_zTrans.lOrigTransNo)
   COLUMN_ENTRY(43,	m_zTrans.lBlockTransNo)

   COLUMN_ENTRY(44,	m_zTrans.sXID)
   COLUMN_ENTRY(45,	m_zTrans.lXTransNo)
   COLUMN_ENTRY(46,	m_zTrans.sXSecNo)
   COLUMN_ENTRY(47,	m_zTrans.sXWi)

   COLUMN_ENTRY(48,	m_zTrans.sXSecXtend)
   COLUMN_ENTRY(49,	m_zTrans.sXAcctType)
   COLUMN_ENTRY(50,	m_zTrans.iXSecID)
   COLUMN_ENTRY(51,	m_zTrans.sCurrId)

   COLUMN_ENTRY(52,	m_zTrans.sCurrAcctType)
   COLUMN_ENTRY(53,	m_zTrans.sIncCurrId)
   COLUMN_ENTRY(54,	m_zTrans.sIncAcctType)

   COLUMN_ENTRY(55,	m_zTrans.sXCurrId)
   COLUMN_ENTRY(56,	m_zTrans.sXCurrAcctType)
   COLUMN_ENTRY(57,	m_zTrans.sSecCurrId)

   COLUMN_ENTRY(58,	m_zTrans.sAccrCurrId)
   COLUMN_ENTRY(59,	m_zTrans.fBaseXrate)
   COLUMN_ENTRY(60,	m_zTrans.fIncBaseXrate)

   COLUMN_ENTRY(61,	m_zTrans.fSecBaseXrate)
   COLUMN_ENTRY(62,	m_zTrans.fAccrBaseXrate)
   COLUMN_ENTRY(63,	m_zTrans.fSysXrate)

   COLUMN_ENTRY(64,	m_zTrans.fIncSysXrate)
   COLUMN_ENTRY(65,	m_zTrans.fBaseOpenXrate)
   COLUMN_ENTRY(66,	m_zTrans.fSysOpenXrate)

   COLUMN_ENTRY(67,	m_vOpenTrdDate)
   COLUMN_ENTRY(68,	m_vOpenStlDate)
   COLUMN_ENTRY(69,	m_zTrans.fOpenUnitCost)

   COLUMN_ENTRY(70,	m_zTrans.fOrigYld)
   COLUMN_ENTRY(71,	m_vEffMatDate)
   COLUMN_ENTRY(72,	m_zTrans.fEffMatPrice)

   COLUMN_ENTRY(73,	m_zTrans.sAcctMthd)
   COLUMN_ENTRY(74,	m_zTrans.sTransSrce)
   COLUMN_ENTRY(75,	m_zTrans.sAdpTag)
   COLUMN_ENTRY(76,	m_zTrans.sDivType)

   COLUMN_ENTRY(77,	m_zTrans.fDivFactor)
   COLUMN_ENTRY(78,	m_zTrans.lDivintNo)
   COLUMN_ENTRY(79,	m_vRollDate)
   COLUMN_ENTRY(80,	m_vPerfDate)

   COLUMN_ENTRY(81,	m_zTrans.sMiscDescInd)
   COLUMN_ENTRY(82,	m_zTrans.sDrCr)
   COLUMN_ENTRY(83,	m_zTrans.sBalToAdjust)
   COLUMN_ENTRY(84,	m_zTrans.sCapTrans)

   COLUMN_ENTRY(85,	m_zTrans.sSafekInd)
   COLUMN_ENTRY(86,	m_zTrans.sDtcInclusion)
   COLUMN_ENTRY(87,	m_zTrans.sDtcResolve)

   COLUMN_ENTRY(88,	m_zTrans.sReconFlag)
   COLUMN_ENTRY(89,	m_zTrans.sReconSrce)
   COLUMN_ENTRY(90,	m_zTrans.sIncomeFlag)
   COLUMN_ENTRY(91,	m_zTrans.sLetterFlag)

   COLUMN_ENTRY(92,	m_zTrans.sLedgerFlag)
   COLUMN_ENTRY(93,	m_zTrans.sGlFlag)
   COLUMN_ENTRY(94,	m_zTrans.sCreatedBy)
   COLUMN_ENTRY(95,	m_vCreateDate)

   COLUMN_ENTRY(96,	m_zTrans.sCreateTime)
   COLUMN_ENTRY(97,	m_vPostDate)
   COLUMN_ENTRY(98,	m_zTrans.sBkofFrmt)
   COLUMN_ENTRY(99,		m_zTrans.lBkofSeqNo)

   COLUMN_ENTRY(100,	m_zTrans.lDtransNo)
   COLUMN_ENTRY(101,	m_zTrans.fPrice)
   COLUMN_ENTRY(102,	m_zTrans.iRestrictionCode)
END_COLUMN_MAP()

DEFINE_COMMAND (CSelectTransFor, 	
				"SELECT id, trans_no, trans.tran_type, sec_no, wi, \n\
					sec_xtend, acct_type, secid, sec_symbol, units, \n\
					orig_face, unit_cost, tot_cost, orig_cost, \n\
					pcpl_amt, opt_prem, amort_val, basis_adj, \n\
					comm_gcr, net_comm, comm_code, sec_fees, \n\
					misc_fee1, fee_code1, misc_fee2, fee_code2, \n\
					accr_int, income_amt, net_flow, broker_code, \n\
					broker_code2, trd_date, stl_date, eff_date, \n\
					entry_date, taxlot_no, xref_trans_no, \n\
					pend_div_no, rev_trans_no, rev_type, \n\
					new_trans_no, orig_trans_no, block_trans_no, \n\
					x_id, x_trans_no, x_sec_no, x_wi, \n\
					x_sec_xtend, x_acct_type, x_secid, curr_id, \n\
					curr_acct_type, inc_curr_id, inc_acct_type, \n\
					x_curr_id, x_curr_acct_type, sec_curr_id, \n\
					accr_curr_id, base_xrate, inc_base_xrate, \n\
					sec_base_xrate, accr_base_xrate, sys_xrate, \n\
					inc_sys_xrate, base_open_xrate, sys_open_xrate, \n\
					open_trd_date, open_stl_date, open_unit_cost, \n\
					orig_yld, eff_mat_date, eff_mat_price, \n\
					acct_mthd, trans_srce, adp_tag, div_type, \n\
					div_factor, divint_no, roll_date, perf_date, \n\
					misc_desc_ind, trans.dr_cr, bal_to_adjust, cap_trans, \n\
					safek_ind, dtc_inclusion, dtc_resolve, \n\
					recon_flag, recon_srce, income_flag, letter_flag, \n\
					ledger_flag, gl_flag, created_by, create_date, \n\
					create_time, post_date, bkof_frmt, bkof_seq_no, \n\
					dtrans_no, price, restriction_code \n\
				FROM trans, trantype \n\
				WHERE trans.tran_type = trantype.tran_type and trans.dr_cr = trantype.dr_cr \n\
						and id = ? AND eff_date >= ? AND eff_date <= ? \n\
						and rev_trans_no = 0 \n\
						and created_by<>'PORTMOV' and perf_impact<>'X' \n\
				ORDER BY eff_date, sec_no, wi"); 
};

CCommand<CAccessor<CSelectTransFor>, CRowset > cmdSelectTransFor;

ERRSTRUCT PrepareSelectTransFor(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSelectTransFor.m_bPrepared) 
	{
		try 
		{
			hr = cmdSelectTransFor.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdSelectTransFor.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdSelectTransFor.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSelectTransFor.m_vInpEffDate1.vt = VT_DATE;
			cmdSelectTransFor.m_vInpEffDate2.vt = VT_DATE;

			cmdSelectTransFor.m_cRows = 0;
			cmdSelectTransFor.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSelectTransFor.m_spCommand.p, sErr, hr, 
									"PrepareSelectTransFor");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL SelectTransFor(TRANS *pzTR, int iID, long lEffDate1, long lEffDate2, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SelectTransFor", FALSE);
#endif

	*pzErr = PrepareSelectTransFor();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		// if subsequent call with previous params - get next record
		// if new params - re-open query
		if (!(cmdSelectTransFor.m_iID == iID && 
			  cmdSelectTransFor.m_vInpEffDate1.date == lEffDate1 &&
			  cmdSelectTransFor.m_vInpEffDate2.date == lEffDate2 &&
			  cmdSelectTransFor.m_cRows > 0))
		{
			cmdSelectTransFor.m_cRows = 0;
			cmdSelectTransFor.Close();

			cmdSelectTransFor.m_iID = iID;
			SETVARDATE(cmdSelectTransFor.m_vInpEffDate1,lEffDate1);
			SETVARDATE(cmdSelectTransFor.m_vInpEffDate2,lEffDate2);

			hr = cmdSelectTransFor.Open(&psClientRowset, NULL, true);
			if FAILED(hr) 
				throw "Open";
		}

		// and get first/next record
		// before retrieving next row clear current buffer content
		memset(&cmdSelectTransFor.m_zTrans, 0, sizeof(cmdSelectTransFor.m_zTrans));
   		cmdSelectTransFor.m_vTrdDate.date = 0;
   		cmdSelectTransFor.m_vStlDate.date = 0;
   		cmdSelectTransFor.m_vEffDate.date = 0;
   		cmdSelectTransFor.m_vEntryDate.date = 0;
   		cmdSelectTransFor.m_vOpenTrdDate.date = 0;
   		cmdSelectTransFor.m_vOpenStlDate.date = 0;
   		cmdSelectTransFor.m_vEffMatDate.date = 0;
   		cmdSelectTransFor.m_vRollDate.date = 0;
   		cmdSelectTransFor.m_vPerfDate.date = 0;
   		cmdSelectTransFor.m_vCreateDate.date = 0;
   		cmdSelectTransFor.m_vPostDate.date = 0;

		hr = cmdSelectTransFor.MoveNext();
		if FAILED(hr) 
			throw "MoveNext";

		if (hr == S_OK) // got data - pass them back and exit
		{	
			cmdSelectTransFor.m_cRows++;

   			memcpy(pzTR,  &cmdSelectTransFor.m_zTrans, sizeof(*pzTR));
   			pzTR->lTrdDate = cmdSelectTransFor.m_vTrdDate.date;
   			pzTR->lStlDate = cmdSelectTransFor.m_vStlDate.date;
   			pzTR->lEffDate = cmdSelectTransFor.m_vEffDate.date;
   			pzTR->lEntryDate = cmdSelectTransFor.m_vEntryDate.date;
   			pzTR->lOpenTrdDate = cmdSelectTransFor.m_vOpenTrdDate.date;
   			pzTR->lOpenStlDate = cmdSelectTransFor.m_vOpenStlDate.date;
   			pzTR->lEffMatDate = cmdSelectTransFor.m_vEffMatDate.date;
   			pzTR->lRollDate = cmdSelectTransFor.m_vRollDate.date;
   			pzTR->lPerfDate = cmdSelectTransFor.m_vPerfDate.date;
   			pzTR->lCreateDate = cmdSelectTransFor.m_vCreateDate.date;
   			pzTR->lPostDate = cmdSelectTransFor.m_vPostDate.date;

		}
		else // EOF reached
		{
			pzErr->iSqlError = SQLNOTFOUND;
			cmdSelectTransFor.m_cRows = 0; 
			cmdSelectTransFor.Close();
		}

	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SelectTransFor",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSelectTransFor.m_spCommand.p, sErr, hr, 
								"SelectTransFor");
	} // catch
}
// SelectTransFor
//****************************************************************



ERRSTRUCT PrepareSelectHoldTotFor(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	return zErr;
}

DLLAPI void STDCALL SelectHoldTotFor(int iPortfolioId, HOLDTOT *pzHoldTot, char *sHoldtotName, ERRSTRUCT *pzErr)
{
}

//****************************************************************
// SelectSegmainForPortfolio definitions
class CSelectSegmainForPortfolio : public CQuery
{
public:
// data elements
	SEGMAIN			m_zSegmain;

// parameter binding map
BEGIN_PARAM_MAP(CSelectSegmainForPortfolio)
   COLUMN_ENTRY(1,	m_zSegmain.iOwnerID)
END_PARAM_MAP()

// coulmn binding map
BEGIN_COLUMN_MAP(CSelectSegmainForPortfolio)
   COLUMN_ENTRY(1,	m_zSegmain.iID)
   COLUMN_ENTRY(2,	m_zSegmain.iOwnerID)
   COLUMN_ENTRY(3,	m_zSegmain.iSegmentTypeID)
   COLUMN_ENTRY(4,	m_zSegmain.sSegmentName)

   COLUMN_ENTRY(5,	m_zSegmain.sSegmentAbbrev)
   COLUMN_ENTRY(6,	m_zSegmain.sIsInactive)
   COLUMN_ENTRY(7,	m_zSegmain.iSegLevel)
   COLUMN_ENTRY(8,	m_zSegmain.sCalculated)
   COLUMN_ENTRY(9,	m_zSegmain.iSequenceNo)
END_COLUMN_MAP()

DEFINE_COMMAND (CSelectSegmainForPortfolio,	
				"Select id, owner_id, segmenttype_id, segment_name, \n\
						segment_abbrev, isinactive, seglevel, calculated, sequence_no \n\
				from segmain where owner_id = ? \n\
				order by segmenttype_id");
};

CCommand<CAccessor<CSelectSegmainForPortfolio>, CRowset > cmdSelectSegmainForPortfolio;

ERRSTRUCT PrepareSelectSegmainForPortfolio(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSelectSegmainForPortfolio.m_bPrepared)
	{
		try 
		{
			hr = cmdSelectSegmainForPortfolio.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdSelectSegmainForPortfolio.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdSelectSegmainForPortfolio.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSelectSegmainForPortfolio.m_cRows = 0;
			cmdSelectSegmainForPortfolio.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdSelectSegmainForPortfolio.m_spCommand.p, sErr, hr, 
								"PrepareSelectSegmainForPortfolio");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL SelectSegmainForPortfolio(SEGMAIN *pzSegmain, int iID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SelectSegmainForPortfolio", FALSE);
#endif

	*pzErr = PrepareSelectSegmainForPortfolio();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		// if subsequent call - get next record
		// if new params - close/open query
		if (!(cmdSelectSegmainForPortfolio.m_zSegmain.iOwnerID == iID && 
			  cmdSelectSegmainForPortfolio.m_cRows > 0))
		{
			cmdSelectSegmainForPortfolio.m_cRows = 0;
			cmdSelectSegmainForPortfolio.Close();

			cmdSelectSegmainForPortfolio.m_zSegmain.iOwnerID = iID;

			hr = cmdSelectSegmainForPortfolio.Open(&psClientRowset, NULL, true);
			if FAILED(hr) 
				throw "Open";
		}
		// before retrieving next row clear current buffer content
		memset(&cmdSelectSegmainForPortfolio.m_zSegmain, 0, 
				sizeof(cmdSelectSegmainForPortfolio.m_zSegmain));

		// and get the record
		hr = cmdSelectSegmainForPortfolio.MoveNext();
		if FAILED(hr) 
			throw "MoveNext";

		if (hr == S_OK) // got data - pass them back and exit
		{	
			cmdSelectSegmainForPortfolio.m_cRows++;
   			memcpy(pzSegmain,  &cmdSelectSegmainForPortfolio.m_zSegmain, sizeof(*pzSegmain));
		}
		else // EOF reached
		{
			pzErr->iSqlError = SQLNOTFOUND;
			cmdSelectSegmainForPortfolio.m_cRows = 0; 
			cmdSelectSegmainForPortfolio.Close();
		}

	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SelectSegmainForPortfolio",iID,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSelectSegmainForPortfolio.m_spCommand.p, sErr, hr, 
								"SelectSegmainForPortfolio");
	} // catch
}//SelectSegmainForPortfolio
//****************************************************************

//****************************************************************
// InsertContacts definitions
class CInsertContacts : public CQuery
{
public:
// data elements
	CONTACTS		m_zContacts;
	DBSTATUS		m_IDStatus;

// coulmn binding map
BEGIN_COLUMN_MAP(CInsertContacts)
   COLUMN_ENTRY_STATUS(1,	m_zContacts.lID, m_IDStatus)
   COLUMN_ENTRY(2,	m_zContacts.sContactType)
   COLUMN_ENTRY(3,	m_zContacts.sUniqueName)
   COLUMN_ENTRY(4,	m_zContacts.sAbbrev)
   COLUMN_ENTRY(5,	m_zContacts.sDescription)
   COLUMN_ENTRY(6,	m_zContacts.sAddress1)
   COLUMN_ENTRY(7,	m_zContacts.sAddress2)
   COLUMN_ENTRY(8,	m_zContacts.sAddress3)
   COLUMN_ENTRY(9,	m_zContacts.lCityID)
   COLUMN_ENTRY(10,	m_zContacts.lStateID)
   COLUMN_ENTRY(11,	m_zContacts.sZip)
   COLUMN_ENTRY(12,	m_zContacts.lCountryID)
   COLUMN_ENTRY(13,	m_zContacts.sPhone1)
   COLUMN_ENTRY(14,	m_zContacts.sPhone2)
   COLUMN_ENTRY(15,	m_zContacts.sFax1)
   COLUMN_ENTRY(16,	m_zContacts.sFax2)
   COLUMN_ENTRY(17,	m_zContacts.sWebAddress)
   COLUMN_ENTRY(18,	m_zContacts.lDomicileID)
END_COLUMN_MAP()

// param binding map
BEGIN_PARAM_MAP(CInsertContacts)
   COLUMN_ENTRY(1,	m_zContacts.sUniqueName)
   COLUMN_ENTRY(2,	m_zContacts.sContactType)
END_PARAM_MAP()

DEFINE_COMMAND (CInsertContacts,	
				"SELECT	id, contacttype, uniquename, abbrev, \n\
						description, address1, address2, address3, \n\
						city_id, state_id, zip, country_id, \n\
						phone1, phone2, fax1, fax2, webaddress, domicile_id \n\
				 FROM CONTACTS WHERE uniquename = ? and contacttype = ?");
};

CCommand<CAccessor<CInsertContacts> > cmdInsertContacts;


ERRSTRUCT PrepareInsertContacts(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdInsertContacts.m_bPrepared)
	{
		try 
		{
			hr = cmdInsertContacts.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdInsertContacts.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdInsertContacts.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdInsertContacts.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdInsertContacts.m_spCommand.p, sErr, hr, 
									"PrepareInsertContacts");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL InsertContacts(CONTACTS *pzContacts, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "InsertContacts", FALSE);
#endif

	*pzErr = PrepareInsertContacts();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	// set data before creating server side cursor
		memcpy(&cmdInsertContacts.m_zContacts, pzContacts, sizeof(cmdInsertContacts.m_zContacts));
		hr = cmdInsertContacts.Open(&psIdentityInsert, NULL, true);
		if FAILED(hr) 
			throw "Open";

		// set to ignore ID (identity) field while inserting new record
		cmdInsertContacts.m_IDStatus = DBSTATUS_S_IGNORE;

		hr = cmdInsertContacts.Insert(0, true); // insert new row and get it back immediately
		if FAILED(hr) 
			throw "Insert";

		// get record data (to obtain just inserted ID which is an Identity column)
		hr = cmdInsertContacts.GetData();
		if FAILED(hr) 
			throw "GetData";

		if (hr == S_OK) // pass ID back
		{	
			pzContacts->lID = cmdInsertContacts.m_zContacts.lID;
		}
		else	 
			pzErr->iSqlError = SQLNOTFOUND;

		cmdInsertContacts.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("InsertContacts",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdInsertContacts.m_spCommand.p, sErr, hr, 
								"InsertContacts");
	} // catch
}//InsertContacts
//****************************************************************
//****************************************************************
// DeleteCompMemTransEx definitions

class CDeleteCompMemTransEx : public CQuery
{
public:
// data elements
	int		m_iCompID;
	VARIANT m_vCompDate;
	
// param binding map
BEGIN_PARAM_MAP(CDeleteCompMemTransEx)
   COLUMN_ENTRY(1, m_vCompDate);
   COLUMN_ENTRY(2, m_iCompID);
END_PARAM_MAP()

DEFINE_COMMAND (CDeleteCompMemTransEx, "delete from MAPCOMPMEMTRANSEX  \
									where CompDate=? and CompID=? ")
};

CCommand<CAccessor<CDeleteCompMemTransEx> > cmdDeleteMapCompMemTransEx;

ERRSTRUCT PrepareDeleteMapCompMemTransEx(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdDeleteMapCompMemTransEx.m_bPrepared)
	{
		try 
		{
			hr = cmdDeleteMapCompMemTransEx.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdDeleteMapCompMemTransEx.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdDeleteMapCompMemTransEx.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdDeleteMapCompMemTransEx.m_vCompDate.vt = VT_DATE;
			cmdDeleteMapCompMemTransEx.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdDeleteMapCompMemTransEx.m_spCommand.p, sErr, hr, 
									"PrepareDeleteMapCompMemTransEx");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL DeleteMapCompMemTransEx(long lCOmpDate, int iCompID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "DeleteMapCompMemTransEx", FALSE);
#endif

	*pzErr = PrepareDeleteMapCompMemTransEx();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	// set data before creating server side cursor
		SETVARDATE(cmdDeleteMapCompMemTransEx.m_vCompDate,lCOmpDate);
		cmdDeleteMapCompMemTransEx.m_iCompID = iCompID;

		hr = cmdDeleteMapCompMemTransEx.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec";

		cmdDeleteMapCompMemTransEx.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("DeleteMapCompMemTransEx",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdDeleteMapCompMemTransEx.m_spCommand.p, sErr, hr, 
								"DeleteMapCompMemTransEx");
	} // catch
}//DeleteMapCompMemTransEx
//****************************************************************

// InsertMapCompMemTransEx definitions
class CInsertMapCompMemTransEx : public CQuery
{
public:
// data elements
	MAPCOMPMEMTRANSEX   m_zMapCompMemTransEx;
	VARIANT             m_vCompDate;

// column binding map
BEGIN_PARAM_MAP(CInsertMapCompMemTransEx)
   COLUMN_ENTRY(1,	m_vCompDate)
   COLUMN_ENTRY(2,	m_zMapCompMemTransEx.iCompID)
   COLUMN_ENTRY(3,	m_zMapCompMemTransEx.lCompTrans)
   COLUMN_ENTRY(4,	m_zMapCompMemTransEx.iCompMem)
   COLUMN_ENTRY(5,	m_zMapCompMemTransEx.lCompMemTrans)
END_PARAM_MAP()

DEFINE_COMMAND (CInsertMapCompMemTransEx,	
				"INSERT into MAPCOMPMEMTRANSEX \
					(CompDate, \
					CompID, \
					CompTrans, \
					CompMem, \
					CompMemTrans) \
				 VALUES (?, ?, ?, ?, ?) ");
};

CCommand<CAccessor<CInsertMapCompMemTransEx> > cmdInsertMapCompMemTransEx;

ERRSTRUCT PrepareInsertMapCompMemTransEx(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdInsertMapCompMemTransEx.m_bPrepared)
	{
		try 
		{
			hr = cmdInsertMapCompMemTransEx.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdInsertMapCompMemTransEx.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdInsertMapCompMemTransEx.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdInsertMapCompMemTransEx.m_vCompDate.vt = VT_DATE;
			cmdInsertMapCompMemTransEx.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdInsertMapCompMemTransEx.m_spCommand.p, sErr, hr, 
									"PrepareInsertMapCompMemTransEx");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL InsertMapCompMemTransEx(MAPCOMPMEMTRANSEX  zMap, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "InsertMapCompMemTransEx", FALSE);
#endif

	*pzErr = PrepareInsertMapCompMemTransEx();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		memcpy(&cmdInsertMapCompMemTransEx.m_zMapCompMemTransEx,  &zMap, sizeof(zMap));
		SETVARDATE(cmdInsertMapCompMemTransEx.m_vCompDate,zMap.lCompDate);

		hr = cmdInsertMapCompMemTransEx.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec";

		cmdInsertMapCompMemTransEx.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("InsertMapCompMemTransEx",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdInsertMapCompMemTransEx.m_spCommand.p, sErr, hr, 
								"InsertMapCompMemTransEx");
	} // catch
}//InsertMapCompMemTransEx
//****************************************************************

// Build_Merge_CompSegMap  definitions
// build table of members for a period + tax rate + member & composite aggregation methods
#define ANY_SQL_000 "SET NOCOUNT ON \n\0"
#define SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED \n\0"
#define SQL_SET_TRANS_ISOLATION_LVL_COMMITTED "SET TRANSACTION ISOLATION LEVEL READ COMMITTED \n\0"
// Build_Merge_CompSegMap_SQL_001  used for default merge called by BuildMergeCompSegMap_SQL
#define Build_Merge_CompSegMap_SQL_001 "DECLARE @SessionID uniqueidentifier \n\
	SET @SessionID = newid() \n\
	SELECT CAST(@SessionID as varchar(36)) \n\
	\n\
	EXEC dbo.usp_WtdAverageMerge_Compport @SessionID, ?,?,? \n\0"

	
#define Build_Merge_CompSegMap_SQL_002 	" EXEC dbo.usp_WtdAverageMerge_CompSegmap @SessionID, ?, ?, ?  \n\0"

// Build_Merge_CompSegMap_SQL_003  used for non-default merge called by BuildMergeCompport_SQL
#define Build_Merge_CompSegMap_SQL_003 "DECLARE @SessionID uniqueidentifier \n\
	SET @SessionID = ? \n\
	SELECT CAST(@SessionID as varchar(36)) \n\
	\n\
  UPDATE Merge_CompSegMap SET EffStartDate = '12/30/1899', EffEndDate = GetDate() \n\
  WHERE sessionid = @sessionid and EffStartDate IS NULL and EffEndDate IS NULL \n\
	EXEC dbo.usp_WtdAverageMerge_Compport @SessionID, ?,?,? \n\0"

	
	
/*
	INSERT INTO Merge_Compport WITH (ROWLOCK) \n\
		(SessionID, OwnerID, ID, CompAggMthd, MemberAggMthd, TaxRate) \n\
	SELECT @SessionID, c1.ownerid, c1.id, \n\
		ISNULL((SELECT pi1.AggregateMethod FROM portinfo pi1 WHERE pi1.id = p.id) , 0), \n\
		ISNULL(cpa.AggregateMethod, 'T'), \n\
		CASE WHEN ? >'1/1/2003' THEN 35.00 \n\
         WHEN ? >'1/1/2002' THEN 38.60 \n\
         WHEN ? >'1/1/2001' THEN 39.10 ELSE 39.60 END \n\
		FROM portmain p \n\
		JOIN compport c1 ON p.id = c1.ownerid \n\
		LEFT OUTER JOIN compportaggregate cpa ON cpa.ownerid = c1.ownerid AND cpa.id = c1.id \n\
		WHERE p.id = ? AND c1.included='Y' \n\
		AND c1.DateRangeBegin = (SELECT MAX(DateRangeBegin) FROM compport cp2 \n\
														WHERE cp2.ownerid = c1.ownerid AND \n\
                             cp2.id = c1.id  AND cp2.DateRangeBegin <= ?) \n\
		AND p.portfoliotype IN (1,6,7) \n\
		AND p.deletedate IS NULL \n\
		AND EXISTS \n\
			(SELECT * FROM portmain p \n\
       WHERE p.id=c1.id AND ISNULL(p.inceptiondate, '1899-12-30') <= ? \n\
						AND ISNULL(p.deletedate, '9999-12-31') >= ?) \n\
		\n\
		UPDATE Merge_Compport WITH (ROWLOCK) SET TaxRate = \n\
						ISNULL((SELECT TOP 1 FedIncomeRate \n\
                     FROM porttax pt \n\
                     WHERE pt.id = 0 AND taxdate <= ? \n\
                     ORDER BY taxdate DESC),TaxRate) \n\
		WHERE SessionID = @SessionID \n\
		\n\
		UPDATE Merge_Compport WITH (ROWLOCK) SET TaxRate = \n\
						ISNULL((SELECT TOP 1 FedIncomeRate \n\
                     FROM porttax pt \n\
                     WHERE pt.id = Merge_Compport.id AND taxdate <= ? \n\
                     ORDER BY taxdate DESC),TaxRate) \n\
		WHERE SessionID = @SessionID \n\
		\n\
		UPDATE Merge_Compport WITH (ROWLOCK) SET TaxRate = 1 - TaxRate / 100 \n\
		WHERE SessionID = @SessionID \n\0"
*/

// default industry level segments
/*
#define Build_Merge_CompSegMap_SQL_002 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID,	'IndLvl-'+LEFT(c.name,50), smm.segmenttype_id, smc.owner_id, smc.id, \n\
		cp.id, smm.id, 1, c.level_id, c.id, smm.segmenttype_id, taxrate \n\
	FROM Merge_Compport cp \n\
	LEFT OUTER JOIN  segmain smm  ON cp.id = smm.owner_id \n\
	JOIN segments c  ON smm.segmenttype_id = c.id \n\
	LEFT JOIN cbycSegmap as cmap on cmap.segmentid = smm.SegmentType_ID \n\
	LEFT OUTER JOIN segmain smc  on cp.ownerid = smc.owner_id and c.id = smc.segmenttype_id \n\
  WHERE  ISNULL(NULLIF(LTRIM(smc.calculated),''),'F')<>'T' \n\
	AND ISNULL(NULLIF(LTRIM(smc.IsInactive),''),'F') = 'F' \n\
	AND (cmap.SegmentID is Null or cmap.SegmentID = 1) \n\
	AND cp.SessionID = @SessionID \n\
	AND ((cp.CompAggMthd = 0) OR \n\
        ((cp.CompAggMthd = 2) and ((c.level_id <> 400) OR (cp.MemberAggMthd = 'A'))) \n\
	 OR ((cp.CompAggMthd = 1) and (((c.level_id = 400) and (cp.MemberAggMthd = 'A')) \n\
	 or ((c.level_id = 0) and (cp.memberaggmthd = 'T')))))   \n\0"
 

// calculated segments (1st level only)
#define Build_Merge_CompSegMap_SQL_003 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, 'Calc-'+c.name, smc.segmenttype_id, smc.owner_id, smc.id, \n\
		cp.id, smm.id, 1, c.level_id, c.id, smm.segmenttype_id, taxrate \n\
	FROM segments c, segmain smc, Merge_Compport cp, segmain smm, segtree st \n\
	WHERE c.id = smc.segmenttype_id \n\
	AND smc.owner_id = cp.ownerid \n\
	AND cp.ownerid = smc.owner_id \n\
	AND smm.owner_id =  cp.id AND smm.segmenttype_id = st.child_segmenttype_id \n\
	AND ISNULL(NULLIF(LTRIM(smc.calculated),''),'F') = 'T' \n\
	AND st.owner_id = cp.ownerid AND st.parent_id = smc.id \n\
	AND ISNULL(NULLIF(LTRIM(smc.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND ((cp.CompAggMthd = 0) OR  \n\
         ((cp.CompAggMthd=2) and ((c.level_id <> 400) OR (cp.MemberAggMthd = 'A'))) ) \n\0"
			// use "industry level" segments only if composite say so

// total composite by total of members 
// use "category" segments only if composite say so
// and don't pick up member's total portfolio if it is already there
#define Build_Merge_CompSegMap_SQL_004 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, 'Asset-'+ c.name, 1, cp.OwnerID, cp.OwnerID, cp.ID, smm.id, 1, 0, 1, \n\
	smm.segmenttype_id, taxrate  \n\
	FROM Merge_Compport cp  \n\
	JOIN SEGMAIN smm on smm.owner_id = cp.ID  \n\
	join  segments c on c.id = smm.segmenttype_id  \n\
	WHERE cp.SessionID = @SessionID  \n\
	AND (cp.CompAggMthd = 1 and c.level_id = 400 and cp.MemberAggMthd = 'A') \n\0"

// portfolio category segments
// use "category" segments only if composite say so
#define Build_Merge_CompSegMap_SQL_005 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, 'PortC-'+LEFT(ut.name,15)+'/'+left(UN.NAME,15),	sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pc.portid, pc.portid, c.parentid, c.LevelNumber, c.levelid, 1, taxrate \n\
	FROM portcategory pc, segmain sm, \n\
			userdefcatnames un,  userdefcattypes ut, \n\
			cbycsegmap c, Merge_Compport cp \n\
	WHERE pc.portid = cp.id \n\
	AND pc.deletedate = '12/30/1899' \n\
	AND pc.effdate = (select max(pc1.effdate) from portcategory pc1 where pc1.portid = cp.id and pc1.effdate <= ? and pc1.deletedate = '12/30/1899' and pc1.categorytypeid = pc.categorytypeid)	\n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltypeid = pc.categorytypeid AND c.levelid = pc.categoryid \n\
	AND cp.ownerid = sm.owner_id AND c.leveltype='category' \n\
	AND c.levelid = un.id AND un.CategoryTypeId = ut.id \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

// by segment
#define Build_Merge_CompSegMap_SQL_006 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype, smc.segmenttype_id, smc.owner_id, smc.id, \n\
		smm.owner_id, smm.id, c.parentid, c.levelnumber, c.levelid, smm.segmenttype_id, taxrate \n\
	FROM cbycsegmap c, segmain smc, Merge_Compport cp, segmain smm \n\
	WHERE c.leveltype = 'segment' \n\
	AND c.segmentid = smc.segmenttype_id \n\
	AND smc.owner_id = cp.ownerid \n\
	AND cp.ownerid = smc.owner_id \n\
	AND smm.owner_id =  cp.id AND smm.segmenttype_id = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(smc.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

// by contacts
#define Build_Merge_CompSegMap_SQL_007 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype+'-ADM', sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pm.id, pm.id, c.parentid, c.levelnumber, c.levelid, 1, taxrate \n\
	FROM segmain sm, cbycsegmap c, Merge_Compport cp, portmain pm \n\
	WHERE cp.ownerid = sm.owner_id \n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltype = 'contact' and c.leveltypeid='14' \n\
	AND pm.id=cp.id and pm.administrator = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

#define Build_Merge_CompSegMap_SQL_008 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype+'-CLIENT', sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pm.id, pm.id, c.parentid, c.levelnumber, c.levelid, 1, taxrate \n\
	FROM segmain sm, cbycsegmap c, Merge_Compport cp, portclie pm \n\
	WHERE cp.ownerid = sm.owner_id \n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltype = 'contact' and c.leveltypeid='12' \n\
	AND pm.id=cp.id and pm.relation_id = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

#define Build_Merge_CompSegMap_SQL_009 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype+'-CLTYPE', sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pm.id, pm.id, c.parentid, c.levelnumber, c.levelid, 1, taxrate \n\
	FROM segmain sm, cbycsegmap c, Merge_Compport cp, portclie pm \n\
	WHERE cp.ownerid = sm.owner_id \n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltype = 'contact' AND c.leveltypeid='26' \n\
	AND pm.id=cp.id AND pm.clienttype_id = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

#define Build_Merge_CompSegMap_SQL_010 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype+'-MNGR', sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pm.id, pm.id, c.parentid, c.levelnumber, c.levelid, 1, taxrate \n\
	FROM segmain sm, cbycsegmap c, Merge_Compport cp, portmain pm \n\
	WHERE cp.ownerid = sm.owner_id \n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltype = 'contact' AND c.leveltypeid='16' \n\
	AND pm.id=cp.id AND pm.manager = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'T' \n\0"

#define Build_Merge_CompSegMap_SQL_011 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, c.leveltype+'-UC', sm.segmenttype_id, sm.owner_id, sm.id, \n\
		pm.id, pm.id, c.parentid, c.levelnumber, c.levelid, 1, taxrate \n\
	FROM segmain sm, cbycsegmap c, Merge_Compport cp, portcontacts pm \n\
	WHERE cp.ownerid = sm.owner_id \n\
	AND c.segmentid = sm.segmenttype_id \n\
	AND c.leveltype = 'contact' AND c.leveltypeid in ('52', '53', '54', '56') \n\
	AND pm.id=cp.id AND pm.itemtype = c.leveltypeid AND pm.relation_id = c.levelid \n\
	AND ISNULL(NULLIF(LTRIM(sm.IsInactive),''),'F') = 'F' \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd in (1,2) AND cp.MemberAggMthd = 'T' \n\0"

// asset category segments
#define Build_Merge_CompSegMap_SQL_012 	"INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, ISNULL('AsstC('+LEFT(ut.name, 15)+')='+LEFT(un.name,15)+'/'+LEFT(hac.sec_no,12),ssm.secno), \n\
		smc.segmenttype_id, smc.owner_id, smc.id, \n\
		cp.id, sm.id, c.parentid, c.levelnumber, ISNULL(hac.CatValue,-1),	sm.segmenttype_id, taxrate \n\
	FROM Merge_Compport cp \n\
	JOIN segmain smc ON smc.owner_id = cp.ownerid \n\
	JOIN segments sg ON sg.id = smc.segmenttype_id \n\
	JOIN cbycsegmap c ON smc.segmenttype_id = c.segmentid AND c.leveltype = 'category' \n\
        AND c.levelnumber = sg.level_id \n\
	JOIN segmain sm ON sm.owner_id=cp.id  \n\
	JOIN secsegmap ssm ON  ssm.segmentid = sm.segmenttype_id \n\
	LEFT OUTER JOIN histassetcat hac ON hac.CatValue = c.LevelID \n\
        AND ssm.secno = hac.sec_no and ssm.wi = hac.wi \n\
        AND hac.deletedate = '1899/12/30' \n\
	LEFT OUTER JOIN userdefcatnames un ON un.id = hac.catvalue AND un.CategoryTypeID=c.LevelTypeID \n\
	LEFT OUTER JOIN userdefcattypes ut ON un.CategoryTypeID = ut.id \n\
				AND hac.EffDate = (SELECT MAX(EffDate) \n\
          FROM histassetcat hm, userdefcatnames u \n\
          WHERE hm.deletedate = '1899/12/30' AND \n\
                u.id = hm.CatValue AND \n\
                hm.sec_no = hac.sec_no AND hm.wi = hac.wi AND hm.effdate <= ? \n\
          GROUP BY sec_no, wi, u.CategoryTypeID \n\
          HAVING un.CategoryTypeID = u.CategoryTypeID) \n\
	WHERE cp.CompAggMthd IN (1,2) AND cp.MemberAggMthd = 'A' \n\
	AND cp.SessionID = @SessionID \n\
	AND ISNULL(NULLIF(LTRIM(smc.IsInactive),''),'F') = 'F' \n\
	AND ((hac.catvalue IS NOT NULL  AND ut.id IS NOT NULL) \n\
				OR (hac.catvalue IS NULL AND c.levelid=0)) \n\0"

//xxx

#define Build_Merge_CompSegMap_SQL_013 "UPDATE MCS \n\
	SET Segmenttype_ID = c.SegmentID, name = 'ALT-'+ Left(mcs.name,15), \n\
	ID = sm.id, mcs.ParentRuleID = 2 \n\
FROM Merge_Compport mc \n\
JOIN AlternateCategories ac on ac.Portid = mc.ID AND mc.MemberAggMthd = 'A' \n\
and ac.DeleteDate = '12/30/1899' \n\
Join SecSegMap ssm on ssm.SecNo = ac.Sec_NO  \n\
JOIN Merge_CompSegMap mcs  on mcs.sessionid = mc.SessionID and mcs.MemberSegType = ssm.SegmentID \n\
and mcs.MemberPortID = ac.Portid \n\
and mcs.CatValue <>-1 \n\
JOIN CByCSegmap co on co.SegmentID = mcs.SegmentType_ID and co.LevelTypeID = ac.CategoryTypeID\n\
JOIN CByCSegmap c on c.ParentID = co.parentid \n\
and  co.LevelTypeID = c.LevelTypeID and c.LevelID = ac.CategoryID\n\
JOIN Segmain sm on sm.owner_id = mc.OwnerID and sm.segmenttype_id = c.SegmentID \n\
where mc.SessionID = @SessionID \n\
AND ac.EffBeginDate <= ? and (ac.EffEndDate >= ? or ac.EffEndDate = '12/30/1899') \n\0"




#define Build_Merge_CompSegMap_SQL_014a  "WHILE exists (select c.segmentid \n\
	from Merge_Compport cp \n\
	JOIN Merge_CompSegMap mcs on mcs.Owner_ID = cp.OwnerID and ParentRuleID = 2 \n\
	and mcs.SessionID = cp.SessionID and cp.ID = mcs.MemberPortID \n\
	and mcs.CatValue <> -1 \n\
	JOIN CByCSegmap c on c.ParentID = mcs.SegmentType_ID \n\
	Join SEGMAIN sm on sm.owner_id = mcs.Owner_ID and sm.segmenttype_id = c.SegmentID \n\
	and sm.isinactive = 'f' \n\
	left join Merge_CompSegMap  cc on cc.SegmentType_ID = c.SegmentID \n\
	and cc.SessionID = cp.SessionID \n\
	WHERE cp.SessionID = @SessionID and cc.SegmentType_ID is null \n\
	and c.LevelType <> 'security') BEGIN \n\
	INSERT INTO Merge_CompSegMap(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT cp.sessionid, 'alt-'+Left(s1.name,15), c.segmentid, cp.ownerid, sm.id, mcs.memberPortid, mcs.membersegid,\n\
	mcs.Parentruleid, c.levelNumber, c.levelid, mcs.MemberSegType, cp.taxrate\n\
		FROM Merge_Compport cp \n\
		JOIN Merge_CompSegMap mcs on mcs.Owner_ID = cp.OwnerID and ParentRuleID = 2 \n\
		and mcs.SessionID = cp.SessionID and cp.ID = mcs.MemberPortID \n\
		and mcs.CatValue <> -1 \n\
		JOIN CByCSegmap c on c.ParentID = mcs.SegmentType_ID \n\
		join segments s1 on s1.id = c.SegmentID \n\
		JOIN SEGMAIN sm on sm.owner_id = mcs.Owner_ID and sm.segmenttype_id = c.SegmentID \n\
		and sm.isinactive = 'f'  \n\
		LEFT JOIN Merge_CompSegMap  cc on cc.SegmentType_ID = c.SegmentID and cc.MemberPortID = mcs.MemberPortID \n\
		and cc.SessionID = cp.SessionID \n\
		WHERE cp.SessionID = @SessionID and cc.SegmentType_ID is null  \n\
		and c.LevelType <> 'security' END \n\0"
/*
#define Build_Merge_CompSegMap_SQL_014a  "	INSERT INTO Merge_CompSegMap(SessionID, \n\
	Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT cp.sessionid, 'alt-'+s1.name, c.segmentid, cp.ownerid, sm.id, mcs.memberPortid, mcs.membersegid,\n\
	mcs.Parentruleid, c.levelNumber, c.levelid, mcs.MemberSegType, cp.taxrate\n\
		FROM Merge_Compport cp \n\
		JOIN Merge_CompSegMap mcs on mcs.Owner_ID = cp.OwnerID and ParentRuleID = 2 \n\
		and mcs.SessionID = cp.SessionID and cp.ID = mcs.MemberPortID \n\
		and mcs.CatValue <> -1 \n\
		JOIN CByCSegmap c on c.ParentID = mcs.SegmentType_ID \n\
		join segments s1 on s1.id= c.SegmentID \n\
		JOIN SEGMAIN sm on sm.owner_id = mcs.Owner_ID and sm.segmenttype_id = c.SegmentID \n\
		and sm.isinactive = 'f'  \n\
		LEFT JOIN Merge_CompSegMap  cc on cc.SegmentType_ID = c.SegmentID and cc.MemberPortID = mcs.MemberPortID \n\
		and cc.SessionID = cp.SessionID \n\
		WHERE cp.SessionID = @SessionID and cc.SegmentType_ID is null  \n\
		and c.LevelType <> 'security' \n\0"
*/

/*
// Switch default asset to override asset if necessary

#define Build_Merge_CompSegMap_SQL_014b  "UPDATE MCS \n\
	SET Segmenttype_ID = c.SegmentID, ID = sm.id, ParentRuleID = 3, \n\
	LevelNumber = c.LevelNumber, Name = 'ALT-'+ mcs.Name  \n\
FROM Merge_Compport mc  \n\
JOIN AlternateCategories ac on ac.Portid = mc.ID AND mc.MemberAggMthd = 'A' \n\
and ac.DeleteDate = '12/30/1899' \n\
Join SecSegMap ssm on ssm.SecNo = ac.Sec_NO \n\
JOIN Merge_CompSegMap mcs  on mcs.sessionid = mc.SessionID and mcs.MemberSegType = ssm.SegmentID \n\
and mcs.MemberPortID = ac.Portid \n\
and mcs.CatValue <>-1  \n\
and mcs.SegmentType_ID = ssm.SegmentID \n\
JOIN Merge_CompSegMap mcsp  on mcsp.sessionid = mc.SessionID \n\
and mcsp.MemberSegType = ssm.SegmentID \n\
and mcsp.MemberPortID = ac.Portid  \n\
JOIN CByCSegmap co on co.SegmentID = mcsp.SegmentType_ID  \n\
JOIN CByCSegmap c on c.ParentID = co.segmentid and  c.LevelTypeID = 18 and c.LevelID = ssm.SegmentID \n\
JOIN Segmain sm on sm.owner_id = mc.OwnerID and sm.segmenttype_id = c.SegmentID and sm.isinactive ='f' \n\
where mc.SessionID = @SessionID \n\
AND ac.EffBeginDate <= ? and (ac.EffEndDate >= ? or ac.EffEndDate = '12/30/1899') \n\0"

 
//Delete an asset if it is an override not shown in the composite

#define Build_Merge_CompSegMap_SQL_014c  "DELETE FROM MCS \n\
FROM Merge_Compport mc  \n\
JOIN AlternateCategories ac on ac.Portid = mc.ID AND mc.MemberAggMthd = 'A' and ac.DeleteDate = '12/30/1899' \n\
Join SecSegMap ssm on ssm.SecNo = ac.Sec_NO \n\
JOIN Merge_CompSegMap mcs  on mcs.sessionid = mc.SessionID and mcs.MemberSegType = ssm.SegmentID \n\
and mcs.MemberPortID = ac.Portid and mcs.CatValue <>-1  \n\
and mcs.SegmentType_ID = ssm.SegmentID \n\
JOIN Merge_CompSegMap mcsp  on mcsp.sessionid = mc.SessionID \n\
and mcsp.MemberSegType = ssm.SegmentID AND mcsp.MemberPortID = ac.Portid  \n\
JOIN CByCSegmap co on co.SegmentID = mcsp.SegmentType_ID AND co.LevelID = ac.CategoryID \n\
JOIN Merge_CompSegMap mcsp2  on mcsp2.sessionid = mc.SessionID \n\
AND mcsp2.MemberSegType = ssm.SegmentID AND mcsp.MemberPortID = ac.Portid  \n\
LEFT JOIN CByCSegmap co2 on co2.SegmentID = mcsp2.SegmentType_ID \n\
LEFT JOIN CByCSegmap c on c.ParentID = co2.segmentid and  c.LevelTypeID = 18 and c.LevelID = ssm.SegmentID \n\
where mc.SessionID = @SessionID \n\
AND NOT EXISTS (Select ID FROM Segmain WHERE Owner_ID = mc.OwnerID and Segmenttype_ID = c.SegmentID \n\
AND IsInactive = 'F') \n\
AND ac.EffBeginDate <= ? and (ac.EffEndDate >= ? or ac.EffEndDate = '12/30/1899') \n\0"
 
//xxxx end
*/
/*
// add "roll down" segments to preserve the tree
#define Build_Merge_CompSegMap_SQL_016a "INSERT INTO Merge_CompSegMap WITH (ROWLOCK) \n\
	(SessionID, Name, SegmentType_ID, Owner_ID, ID, \n\
	MemberPortID, MemberSegID, ParentRuleID, LevelNumber, CatValue, MemberSegType, TaxRate) \n\
	SELECT SessionID, HeaderText, SegmentTypeID, cl.ID, 0, \n\
		cp.id, cp.id, c.parentid, c.LevelNumber, c.levelid, 0, 0 \n\
	FROM Merge_Compport cp, cbyclevels cl, cbycsegmap c \n\
	WHERE cl.id = cp.ownerid AND cl.rolldown = 'T' \n\
	AND cl.SegmentTypeID = c.SegmentID \n\
	AND cp.SessionID = @SessionID \n\
	AND cp.CompAggMthd in (1,2) \n\0"



// remove excessive <unassigned> segments
#define Build_Merge_CompSegMap_SQL_016b "DELETE FROM Merge_CompSegMap WITH (ROWLOCK) \n\
	WHERE SessionID = @SessionID \n\
	AND CatValue = -1 AND EXISTS \n\
			(SELECT * FROM Merge_CompSegMap sm2 \n\
			WHERE sm2.SessionID = Merge_CompSegMap.SessionID \n\
			AND	sm2.memberportid = Merge_CompSegMap.memberportid \n\
			AND sm2.membersegid = Merge_CompSegMap.membersegid \n\
			AND sm2.levelnumber = Merge_CompSegMap.levelnumber \n\
			AND sm2.CatValue <> -1) \n\0"

// remove 'orphaned' leaves of composite segment tree
#define Build_Merge_CompSegMap_SQL_018a "INSERT INTO Merge_Compport WITH (ROWLOCK) \n\
	(SessionID, OwnerID, ID, CompAggMthd, MemberAggMthd, TaxRate) \n\
	VALUES (@SessionID, 0, 0, '', '', 0) \n\
	\n\
	WHILE @@ROWCOUNT > 0 \n\
	BEGIN \n\
		DELETE FROM Merge_CompSegMap WITH (ROWLOCK) \n\
		WHERE SessionID = @SessionID AND	parentruleid not in (1,2,3) AND NOT EXISTS \n\
				(SELECT * FROM Merge_CompSegMap sm2 \n\
				WHERE  sm2.SessionID = Merge_CompSegMap.SessionID \n\
				AND sm2.memberportid = Merge_CompSegMap.memberportid \n\
				AND sm2.segmenttype_id = Merge_CompSegMap.parentruleid \n\
				AND sm2.membersegid = Merge_CompSegMap.membersegid \n\
				AND sm2.catvalue>=0) \n\
		AND NOT EXISTS \n\
				(SELECT * FROM cbyclevels cbl \n\
         WHERE cbl.id = Merge_CompSegMap.owner_id AND cbl.ShowMemberSegments = 'T' \n\
           AND cbl.SegmentTypeID = Merge_CompSegMap.parentruleid) \n\
	END \n\0"

// remove "rolled-down" (consolidated) segments from composite 
#define Build_Merge_CompSegMap_SQL_018aa "DELETE FROM Merge_CompSegMap WITH (ROWLOCK)\n\
    WHERE SessionID = @SessionID AND ID=0 \n\0"
// now drop segments built-in to preserve the tree

#define Build_Merge_CompSegMap_SQL_018b "DELETE FROM Merge_Compport WITH (ROWLOCK) WHERE SessionID = @SessionID \n\0"
#define Build_Merge_CompSegMap_SQL_018c "AND id = 0 \n\0"

#define Build_Merge_CompSegMap_SQL_020 "UPDATE Merge_CompSegMap WITH (ROWLOCK) SET taxrate = m.taxrate \n\
	FROM Merge_Compport m \n\
	WHERE m.sessionid = @SessionID \n\
	AND Merge_CompSegMap.Sessionid = ? \n\
	AND m.ownerid = Merge_CompSegMap.owner_id \n\0"

*/

void BuildMergeCompSegMap_SQL(char *sSegMapSQL)
{
			strcpy_s(sSegMapSQL, MAXSQLSIZE, ANY_SQL_000);
			strcat_s(sSegMapSQL, MAXSQLSIZE, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(sSegMapSQL, MAXSQLSIZE, Build_Merge_CompSegMap_SQL_001);
			strcat_s(sSegMapSQL, MAXSQLSIZE, Build_Merge_CompSegMap_SQL_002);
/*
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_002);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_003);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_004);

			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_005);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_006);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_007);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_008);

			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_009);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_010);

			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_011);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_012);

			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_013);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_014a);
//			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_014b);
//			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_014c);


			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_016a);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_016b);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_018a);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_018aa);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_018b);
			strcat(sSegMapSQL, Build_Merge_CompSegMap_SQL_018c);
*/
			strcat_s(sSegMapSQL, MAXSQLSIZE, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);
}


// BuildMergeCompSegMap definitions
class CBuildMergeCompSegMap : public CQuery
{
public:
// data elements
	char			m_sSessionID[GUID_STR_SIZE+NT];
	int				m_iID;
	VARIANT		m_vMergeTo;
	VARIANT	    m_vMergeFrom;

// column binding map
BEGIN_COLUMN_MAP(CBuildMergeCompSegMap)
   COLUMN_ENTRY(1,	m_sSessionID)
END_COLUMN_MAP()

// param binding map
BEGIN_PARAM_MAP(CBuildMergeCompSegMap)
   COLUMN_ENTRY(1,	m_iID)  //001
   COLUMN_ENTRY(2,	m_vMergeFrom)
   COLUMN_ENTRY(3,	m_vMergeTo)

   COLUMN_ENTRY(4,	m_iID)  
   COLUMN_ENTRY(5,	m_vMergeFrom)
   COLUMN_ENTRY(6,	m_vMergeTo)

/*20140519
   COLUMN_ENTRY(1,	m_vMergeTo)  //001
   COLUMN_ENTRY(2,	m_vMergeTo)
   COLUMN_ENTRY(3,	m_vMergeTo)

 	 COLUMN_ENTRY(4,	m_iID)
   COLUMN_ENTRY(5,	m_vMergeTo)
   COLUMN_ENTRY(6,	m_vMergeTo)
   COLUMN_ENTRY(7,	m_vMergeTo)

   COLUMN_ENTRY(8,	m_vMergeTo)
   COLUMN_ENTRY(9,	m_vMergeTo) //001
   COLUMN_ENTRY(10,	m_vMergeTo) //005
   COLUMN_ENTRY(11,	m_vMergeTo) // 012

   COLUMN_ENTRY(12,	m_vMergeFrom) // 013
   COLUMN_ENTRY(13,	m_vMergeTo) // 013

/* old deleted
   COLUMN_ENTRY(14,	m_vMergeFrom) // 014b
   COLUMN_ENTRY(15,	m_vMergeTo) // 014b
   COLUMN_ENTRY(16,	m_vMergeFrom) // 014c
   COLUMN_ENTRY(17,	m_vMergeTo) // 014c
*/
END_PARAM_MAP()

};

CCommand<CAccessor<CBuildMergeCompSegMap>, CRowset > cmdBuildMergeCompSegMap;

ERRSTRUCT PrepareBuildMergeCompSegMap(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdBuildMergeCompSegMap.m_bPrepared)
	{
		try 
		{
  		BuildMergeCompSegMap_SQL(cmdBuildMergeCompSegMap.m_sAdjSQL);
			
				hr = cmdBuildMergeCompSegMap.Create(dbSession,  cmdBuildMergeCompSegMap.m_sAdjSQL, 
																						DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
//			ULONG ulOrds[] = {1,2,3,4,5,6,7,8,9,10,11,12,13};
			ULONG ulOrds[] = {1,2,3,4,5,6};
			DBPARAMBINDINFO	ParamInfo[6] = 
			{
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// ownerid	1
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// ownerid	5
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from 6
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to 7
/* 5/19/2014 			 
				
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to

			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// ownerid
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from 013
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
 old break			
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from 014b
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from 014c
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
*/ 
			};			
		
			hr = cmdBuildMergeCompSegMap.SetParameterInfo(6, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdBuildMergeCompSegMap.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdBuildMergeCompSegMap.m_vMergeFrom.vt = VT_DATE;
			cmdBuildMergeCompSegMap.m_vMergeTo.vt = VT_DATE;
			cmdBuildMergeCompSegMap.m_cRows = 0;
			cmdBuildMergeCompSegMap.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdBuildMergeCompSegMap.m_spCommand.p, sErr, hr, 
									"PrepareBuildMergeCompSegMap");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL BuildMergeCompSegMap(int iID, long lMergeFrom, long lMergeTo, char *sSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "BuildMergeCompSegMap", FALSE);
#endif

	*pzErr = PrepareBuildMergeCompSegMap();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		sSessionID[0] = '\0';
		cmdBuildMergeCompSegMap.m_sSessionID[0] = '\0';
		cmdBuildMergeCompSegMap.m_iID = iID;
		SETVARDATE(cmdBuildMergeCompSegMap.m_vMergeTo,lMergeTo);
		SETVARDATE(cmdBuildMergeCompSegMap.m_vMergeFrom,lMergeFrom);

#ifdef DEBUG
			FILE        *fp;
	    fp = fopen("compquery.txt", "w");
			fprintf(fp, "%s", cmdBuildMergeCompSegMap.m_sAdjSQL);
			fclose(fp);
#endif

		hr = cmdBuildMergeCompSegMap.Open(&psClientRowset, NULL, true);
		if FAILED(hr)
		    throw "Exec/Open";
 
		hr = cmdBuildMergeCompSegMap.MoveNext();
		if FAILED(hr) 
			throw "MoveNext";

		if (hr == S_OK)
			strcpy_s(sSessionID, STR36LEN, cmdBuildMergeCompSegMap.m_sSessionID);
		else
			pzErr->iSqlError = SQLNOTFOUND;

		cmdBuildMergeCompSegMap.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("BuildMergeCompSegMap",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdBuildMergeCompSegMap.m_spCommand.p, sErr, hr, 
								"BuildMergeCompSegMap");
	} // catch

}//BuildMergeCompSegMap
//****************************************************************

void BuildMergeCompport_SQL(char *sCompportSQL)
{
	strcpy_s(sCompportSQL, MAXSQLSIZE, ANY_SQL_000);
	strcat_s(sCompportSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);
	strcat_s(sCompportSQL, MAXSQLSIZE,Build_Merge_CompSegMap_SQL_003);

	/*			strcat(sCompportSQL, Build_Merge_CompSegMap_SQL_020);
	strcat(sCompportSQL, Build_Merge_CompSegMap_SQL_018b);
	*/
	strcat_s(sCompportSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);
}


// BuildMergeCompport definitions
class CBuildMergeCompport : public CQuery
{
public:
// data elements
	char			m_sInSessionID[GUID_STR_SIZE+NT];
	int				m_iID;
	VARIANT		m_vMergeTo;
	VARIANT		m_vMergeFrom;

// param binding map
BEGIN_PARAM_MAP(CBuildMergeCompport)
   COLUMN_ENTRY(1,	m_sInSessionID) //015
   COLUMN_ENTRY(2,	m_iID)
   COLUMN_ENTRY(3,	m_vMergeFrom)
   COLUMN_ENTRY(4,	m_vMergeTo)

/*
   COLUMN_ENTRY(1,	m_vMergeTo) //001
   COLUMN_ENTRY(2,	m_vMergeTo)
   COLUMN_ENTRY(3,	m_vMergeTo)

 	 COLUMN_ENTRY(4,	m_iID)
   COLUMN_ENTRY(5,	m_vMergeTo)
   COLUMN_ENTRY(6,	m_vMergeTo)
   COLUMN_ENTRY(7,	m_vMergeTo)

   COLUMN_ENTRY(8,	m_vMergeTo)
   COLUMN_ENTRY(9,	m_vMergeTo) //001
   COLUMN_ENTRY(10,	m_sInSessionID) //015
*/
END_PARAM_MAP()

};

CCommand<CAccessor<CBuildMergeCompport>, CRowset > cmdBuildMergeCompport;

ERRSTRUCT PrepareBuildMergeCompport(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdBuildMergeCompport.m_bPrepared)
	{
		try 
		{
  		BuildMergeCompport_SQL(cmdBuildMergeCompport.m_sAdjSQL);
			
			hr = cmdBuildMergeCompport.Create(dbSession, 
											cmdBuildMergeCompport.m_sAdjSQL, 
											DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
//			ULONG ulOrds[] = {1,2, 3,4,5,6,7,8,9,10};
			ULONG ulOrds[] = {1, 2, 3, 4};
			DBPARAMBINDINFO	ParamInfo[4] = 
			{
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeCompport.m_sInSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID 
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// ownerid
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
/*
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to

			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// ownerid
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeCompport.m_sInSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID 
	*/
			};			
		
			hr = cmdBuildMergeCompport.SetParameterInfo(4, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdBuildMergeCompport.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdBuildMergeCompport.m_vMergeTo.vt = VT_DATE;
			cmdBuildMergeCompport.m_vMergeFrom.vt = VT_DATE;  // dont need merge from date
			cmdBuildMergeCompport.m_cRows = 0;
			cmdBuildMergeCompport.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdBuildMergeCompport.m_spCommand.p, sErr, hr, 
									"PrepareBuildMergeCompport");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL BuildMergeCompport(int iID, long lMergeTo, char *sInSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "BuildMergeCompport", FALSE);
#endif

	*pzErr = PrepareBuildMergeCompport();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		strcpy_s(cmdBuildMergeCompport.m_sInSessionID, sInSessionID);
		cmdBuildMergeCompport.m_iID = iID;
		SETVARDATE(cmdBuildMergeCompport.m_vMergeTo,lMergeTo);

#ifdef DEBUG
		FILE        *fp;
	    fp = fopen("compquery.txt", "w");
		fprintf(fp, "%s", cmdBuildMergeCompport.m_sAdjSQL);
		fclose(fp);
#endif

		hr = cmdBuildMergeCompport.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec/Open";

		cmdBuildMergeCompport.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("BuildMergeCompport",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdBuildMergeCompport.m_spCommand.p, sErr, hr, 
								"BuildMergeCompport");
	} // catch

}//BuildMergeCompport
//****************************************************************

#define Build_Merge_UV_SQL_000 "DELETE FROM Merge_UV WITH (ROWLOCK) WHERE SessionID = ? \n\0"
#define Build_Merge_UV_SQL_001 "Exec dbo.usp_WtdAverageMerge_UV ?,?,?,? \n\0"

/*
// INSERT EUV for members - total fund or gross rors
#define Build_Merge_UV_SQL_001 "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID,Portfolio_ID,ID,Ror_Type,UVDate,UnitValue, \n\
Fudge_factor,Stream_Begin_Date,Ror_Source,Src,ActualDate) \n\
SELECT DISTINCT sm.SessionID, uv.*, 'E', sd.ActualDate \n\
	FROM Merge_CompSegMap sm \n\
	JOIN Merge_SData sd \n\
		ON sd.id = sm.membersegid AND sd.portfolio_id = sm.memberportid  \n\
		AND perform_date > ? AND perform_date <= ? \n\
		AND sd.SessionID = sm.SessionID  \n\
	JOIN unitvalue uv ON uv.id = sd.id AND uv.portfolio_id = sd.portfolio_id  \n\
					AND uv.uvdate = sd.ActualDate \n\
					AND ((UV.portfolio_id = uv.id ) or (uv.Ror_type in (1,2,5,8,10))) \n\
	WHERE sm.SessionID = ? \n\0"

// INSERT EUV for members - copy gross rors of segments to net
#define Build_Merge_UV_SQL_001a "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID,Portfolio_ID,ID,Ror_Type,UVDate,UnitValue, \n\
Fudge_factor,Stream_Begin_Date,Ror_Source,Src,ActualDate) \n\
SELECT DISTINCT sm.SessionID, uv.portfolio_id, \n\
 uv.id, \n\
 case uv.ROR_type  \n\
	when 1 then 3  \n\
	when 2 then 4 \n\
	when 8 then 9 \n\
	when 10 then 11 \n\
end ror_type, \n\
uv.uvdate, uv.unitvalue, uv.fudge_factor, uv.stream_begin_date, \n\
  uv.ror_source,'E', sd.ActualDate \n\
	FROM Merge_CompSegMap sm WITH (READPAST, UPDLOCK)  \n\
	JOIN Merge_SData sd WITH (READPAST, UPDLOCK)  \n\
		ON sd.id = sm.membersegid AND sd.portfolio_id = sm.memberportid  \n\
		AND perform_date > ? AND perform_date <= ? \n\
		AND sd.SessionID = sm.SessionID  \n\
	JOIN unitvalue uv ON uv.id = sd.id AND uv.portfolio_id = sd.portfolio_id  \n\
					AND uv.uvdate = sd.ActualDate  \n\
					AND ((UV.portfolio_id <> uv.id ) and (uv.Ror_type in (1,2, 8,10))) \n\
	WHERE sm.SessionID = ? \n\0"



// INSERT BUV for members
#define Build_Merge_UV_SQL_002 "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID,Portfolio_ID,ID,Ror_Type,UVDate,UnitValue, \n\
Fudge_factor,Stream_Begin_Date,Ror_Source,Src,ActualDate) \n\
SELECT DISTINCT um.SessionID, u1.*, 'B', ? \n\
FROM unitvalue u1, Merge_UV um \n\
WHERE um.SessionID = ? \n\
    AND	u1.id = um.id AND u1.portfolio_id = um.portfolio_id  \n\
    AND u1.ror_type = um.ror_type  \n\
    AND u1.stream_begin_date = um.stream_begin_date  \n\
    AND u1.ror_source in (1,2,4,6,7)  \n\
	AND (u1.stream_begin_Date <> ? \n\
	OR exists (SELECT * FROM unitvalue where id = u1.id \n\
	AND uvdate = u1.stream_begin_date and ror_type = u1.ROR_Type)) \n\
	AND ((Um.portfolio_id = um.id) or (um.ror_type in (1,2,5,8,10))) \n\
	AND u1.uvdate = (SELECT min(uv.uvdate) \n\
    FROM Merge_UV UM1 \n\
	JOIN unitvalue uv on uv.id = UM1.id \n\
    WHERE um1.sessionid = UM.Sessionid AND um1.id = uv.id \n\
	AND um1.portfolio_id = uv.portfolio_id  \n\
    AND um1.ror_type = uv.ror_type  \n\
    AND um1.stream_begin_date = uv.stream_begin_date  \n\
    AND uv.uvdate >= ?  \n\
    AND uv.uvdate < ? \n\
    AND uv.ror_source in (1,2,4,6,7)  \n\
	AND ((Um1.portfolio_id = um1.id) or (um1.ror_type in (1,2,5,8,10)))) \n\0"

#define Build_Merge_UV_SQL_002a "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID, Portfolio_ID, ID, Ror_Type, UVDate, UnitValue,  \n\
Fudge_factor, Stream_Begin_Date, Ror_Source, Src, ActualDate) \n\
SELECT distinct um.SessionID,  \n\
 u1.portfolio_id, u1.id,  \n\
case u1.ror_type \n\
	when 1 then 3 \n\
	when 2 then 4 \n\
	when 8 then 9 \n\
	when 10 then 11 \n\
end Ror_type, \n\
u1.uvdate, u1.unitvalue, u1.fudge_factor, u1.stream_begin_date, u1.ror_source,  \n\
'B', ? \n\
FROM unitvalue u1, Merge_UV um WITH (READPAST, UPDLOCK)  \n\
WHERE um.SessionID = ? \n\
    AND u1.ror_type in (1,2,8,10) AND	u1.id = um.id \n\
    AND u1.stream_begin_date = um.stream_begin_date  \n\
    AND u1.ror_source in (1,2,4,6,7) \n\
	AND (u1.stream_begin_Date <> ? \n\
	OR exists (SELECT * FROM unitvalue where id = u1.id \n\
	AND uvdate = u1.stream_begin_date and ror_type = u1.ROR_Type)) \n\
    AND u1.uvdate = (SELECT min(uv.uvdate) \n\
    FROM Merge_UV x\n\
	JOIN unitvalue uv  on x.id = uv.id\n\
    WHERE x.sessionid = um.sessionid \n\
    AND u1.id = UV.ID \n\
	AND u1.ror_type = uv.ror_type  \n\
    AND u1.stream_begin_date = uv.stream_begin_date  \n\
    AND uv.uvdate >= ? \n\
    AND uv.uvdate < ? \n\
    AND uv.ror_source in (1,2,4,6,7)  \n\
    AND ((UV.portfolio_id <> uv.id) and (uv.ror_type in (1,2, 8,10))))\n\0"

#define Build_Merge_UV_SQL_002aa "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID, Portfolio_ID, ID, Ror_Type, UVDate, UnitValue,  \n\
Fudge_factor, Stream_Begin_Date, Ror_Source, Src, ActualDate) \n\
SELECT distinct um.SessionID,um.portfolio_id, um.id, \n\
 um.ror_type, um.stream_Begin_Date, 100.0, 0.0, um.stream_begin_date, 4, \n\
'B', ? \n\
FROM  Merge_UV um WITH (READPAST, UPDLOCK) \n\
WHERE um.SessionID = ? \n\
	AND um.Stream_Begin_Date = ? \n\
	AND NOT EXISTS (SELECT * FROM Merge_UV WHERE Sessionid = UM.Sessionid \n\
	   AND ID = UM.id and ROR_TYPE = um.ROR_type and uvdate = UM.UVDate) \n\0" 

// Delete out any returns pre-inception 
#define Build_Merge_UV_SQL_002c "DELETE FROM U  \n\
FROM MERGE_UV U, Portmain P, SysValues S   \n\
WHERE P.ID = ? and U.SESSIONID = ?  \n\
AND ((u.uvdate <= p.inceptiondate and \n\
u.src = 'E') or (u.uvdate < p.inceptionDate and u.src = 'B')) \n\
AND u.stream_begin_date < p.inceptiondate  \n\
and ((s.Name  ='CALCULATECOMPINCEPTDAYROR' and s.Value = 'NO') \n\
or not exists(select * FROM sysvalues where Name  ='CALCULATECOMPINCEPTDAYROR')) \n\0" 


#define Build_Merge_UV_SQL_002e "UPDATE U  \n\
SET UnitValue = 100.0, Stream_Begin_Date = UVDate \n\
FROM MERGE_UV U, Portmain P, SysValues S \n\
WHERE P.ID = ? and U.SESSIONID = ? AND u.src = 'E'  \n\
AND u.uvdate <= p.inceptiondate and u.stream_begin_date < p.inceptiondate  \n\
and s.Name  ='CALCULATECOMPINCEPTDAYROR' and s.Value = 'YES'  \n\0" 

	

// now replicate member's records if needed 
// to match return types used by composite
#define Build_Merge_UV_SQL_003 "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID,Portfolio_ID,ID,Ror_Type,UVDate,UnitValue, \n\
Fudge_factor,Stream_Begin_Date,Ror_Source,Src,ActualDate) \n\
SELECT DISTINCT OrigUV.SessionID, OrigUV.Portfolio_ID,OrigUV.ID, \n\
RTCompFilter.DestType, OrigUV.UVDate, OrigUV.UnitValue, \n\
OrigUV.Fudge_factor, OrigUV.Stream_Begin_Date, \n\
OrigUV.Ror_Source, OrigUV.Src, OrigUV.ActualDate \n\
FROM (SELECT base.ReturnType AS DestType, base.ReturnType % 100 AS BaseType \n\
	FROM perfreturntype AS base \n\
	JOIN rtntype AS rt ON rt.id = base.ReturnType AND rt.lookuptype=5 \n\
	WHERE base.id=0 AND itemtype=9 \n\
	AND NOT EXISTS  \n\
	(SELECT * FROM perfreturntype AS exclude \n\
	WHERE exclude.id = ? \n\
	AND exclude.returntype = base.returntype \n\
	AND exclude.itemtype = base.itemtype)  \n\
	) RTCompFilter \n\
JOIN Merge_UV OrigUV ON OrigUV.ror_type = RTCompFilter.BaseType \n\
WHERE OrigUV.SessionID = ?  \n\
AND NOT EXISTS (SELECT * FROM Merge_UV DestTypeUV \n\
WHERE DestTypeUV.SessionID = ? \n\
AND DestTypeUV.Portfolio_ID = OrigUV.Portfolio_ID \n\
AND DestTypeUV.ID = OrigUV.ID \n\
AND DestTypeUV.Src = OrigUV.Src  \n\
AND DestTypeUV.Ror_Type = RTCompFilter.DestType) \n\0"

#define Build_Merge_UV_SQL_003a "update Merge_UV set UnitValue = 100.0 where \n\
	sessionid = ? AND uvdate < ? and Stream_begin_date = uvdate \n\
	and ( (month(uvdate) = Month(?)) or \n\
	( (Month(uvDate) + 2 >= Month(?)) and (Month(?) + 3 = Month(?)) ) ) \n\
	OR (UnitValue = -999.00 AND src = 'B') \n\0"

// INSERT BUV for Composite
#define Build_Merge_UV_SQL_004 "INSERT INTO Merge_UV WITH (ROWLOCK) \n\
(SessionID,Portfolio_ID,ID,Ror_Type,UVDate,UnitValue, \n\
Fudge_factor,Stream_Begin_Date,Ror_Source,Src,ActualDate) \n\
SELECT DISTINCT sm.SessionID, uvc.*, 'B', ? \n\
FROM portmain pm JOIN  \n\
	(SELECT DISTINCT id, segmenttype_id, owner_id, SessionID  \n\
	FROM Merge_CompSegMap WHERE SessionID = ?) sm  \n\
        ON owner_id = pm.id  \n\
JOIN unitvalue uvc ON uvc.portfolio_id = sm.owner_id AND uvc.id = sm.id  \n\
        AND uvdate = ? \n\
        AND uvdate < ? AND ror_source IN (1,2,4,6,7)  \n\
WHERE pm.id = ? AND deletedate IS NULL AND portfoliotype IN (1,6,7)  \n\0"

// remove any values brought in by members
// but not matching the return types requested for composite
*/


void BuildMergeUV_SQL(char *sUVSQL)
	{
		strcpy_s(sUVSQL, MAXSQLSIZE,ANY_SQL_000);
		strcat_s(sUVSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

		strcat_s(sUVSQL, MAXSQLSIZE,Build_Merge_UV_SQL_000);
		strcat_s(sUVSQL, MAXSQLSIZE,Build_Merge_UV_SQL_001);
		/*
		strcat(sUVSQL, Build_Merge_UV_SQL_001a);
		strcat(sUVSQL, Build_Merge_UV_SQL_002);
		strcat(sUVSQL, Build_Merge_UV_SQL_002a);
		strcat(sUVSQL, Build_Merge_UV_SQL_002aa);
		strcat(sUVSQL, Build_Merge_UV_SQL_002c);
		strcat(sUVSQL, Build_Merge_UV_SQL_002e);
		strcat(sUVSQL, Build_Merge_UV_SQL_003);
		strcat(sUVSQL, Build_Merge_UV_SQL_003a);
		strcat(sUVSQL, Build_Merge_UV_SQL_004);
		*/
		strcat_s(sUVSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);
	}


// BuildMergeUV definitions
class CBuildMergeUV : public CQuery
{
public:
// data elements
	char		m_sSessionID[GUID_STR_SIZE+NT];
	int			m_iID;
	VARIANT		m_vMergeFrom;
	VARIANT		m_vMergeTo;


// param binding map
BEGIN_PARAM_MAP(CBuildMergeUV)
   COLUMN_ENTRY(1,	m_sSessionID)
   COLUMN_ENTRY(2,	m_sSessionID)
   COLUMN_ENTRY(3,	m_iID)
   COLUMN_ENTRY(4,	m_vMergeFrom)
   COLUMN_ENTRY(5,	m_vMergeTo)
/*
//000
   COLUMN_ENTRY(1,	m_sSessionID)
//001
   COLUMN_ENTRY(2,	m_vMergeFrom)
   COLUMN_ENTRY(3,	m_vMergeTo)
   COLUMN_ENTRY(4,	m_sSessionID)
//001a
   COLUMN_ENTRY(5,	m_vMergeFrom)
   COLUMN_ENTRY(6,	m_vMergeTo)
   COLUMN_ENTRY(7,	m_sSessionID)

//002   
   COLUMN_ENTRY(8,	m_vMergeFrom)
   COLUMN_ENTRY(9,	m_sSessionID)
   COLUMN_ENTRY(10, m_vMergeFrom)
//   COLUMN_ENTRY(11,	m_vMergeTo)
   COLUMN_ENTRY(11,	m_vMergeFrom)
   COLUMN_ENTRY(12,	m_vMergeTo)

//002a
   COLUMN_ENTRY(13,	m_vMergeFrom)
   COLUMN_ENTRY(14,	m_sSessionID)
   COLUMN_ENTRY(15,	m_vMergeFrom)
   COLUMN_ENTRY(16,	m_vMergeFrom)
   COLUMN_ENTRY(17,	m_vMergeTo)

 //002AA
   COLUMN_ENTRY(18,	m_vMergeFrom)
   COLUMN_ENTRY(19,	m_sSessionID)
   COLUMN_ENTRY(20,	m_vMergeFrom)
 //002c
   COLUMN_ENTRY(21,	m_iID)
   COLUMN_ENTRY(22,	m_sSessionID)

//002e
   COLUMN_ENTRY(23,	m_iID)
   COLUMN_ENTRY(24,	m_sSessionID)

//003   
   COLUMN_ENTRY(25,	m_iID)
   COLUMN_ENTRY(26,	m_sSessionID)
   COLUMN_ENTRY(27,	m_sSessionID)
//003a
   COLUMN_ENTRY(28,	m_sSessionID)
   COLUMN_ENTRY(29,	m_vMergeTo)
   COLUMN_ENTRY(30,	m_vMergeTo)
   COLUMN_ENTRY(31,	m_vMergeTo)
   COLUMN_ENTRY(32,	m_vMergeFrom)
   COLUMN_ENTRY(33,	m_vMergeTo)

//004
   COLUMN_ENTRY(34,	m_vMergeFrom)
   COLUMN_ENTRY(35,	m_sSessionID)
   COLUMN_ENTRY(36,	m_vMergeFrom)
   COLUMN_ENTRY(37,	m_vMergeTo)
   COLUMN_ENTRY(38,	m_iID)
   */
END_PARAM_MAP()

};

CCommand<CAccessor<CBuildMergeUV>, CRowset > cmdBuildMergeUV;

ERRSTRUCT PrepareBuildMergeUV(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdBuildMergeUV.m_bPrepared)
	{
		try 
		{
			BuildMergeUV_SQL(cmdBuildMergeUV.m_sAdjSQL);

			#ifdef DEBUG
			   FILE        *fp;
			   fp = fopen("compquery.txt", "w");
			   fprintf(fp, "%s", cmdBuildMergeUV.m_sAdjSQL);
			   fclose(fp);
			#endif		
			
			hr = cmdBuildMergeUV.Create(dbSession, 
								cmdBuildMergeUV.m_sAdjSQL, 
 								DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3,4,5};
			/*{1,2,3,4,5,6,7,8,9,10,11,12,
				13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38}; */
			DBPARAMBINDINFO	ParamInfo[5] = 
			{

			L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
			   							DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 1 
			L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
			   							DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 2 
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,	   // ownerid  -	 3
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 4
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 5
/*
			L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
			   							DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 1 

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 2
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 3
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 4 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 5
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 6
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 7 

			 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 8
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 9 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 10
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	FROM -	 11
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	TO -	 12
			 

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 13
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 14
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 15
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 16
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 17

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 18
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 19
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 20

			 //002c
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,	   // ownerid  -	 21
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 22
			 
			 //002e
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,	   // ownerid  -	 23
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 24

			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,	   // ownerid  -	 25
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 26 
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 27 

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 28 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 29
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 30
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 31
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	From -	 32
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 33

										
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 34
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdBuildMergeUV.m_sSessionID), 
										DBPARAMFLAGS_ISINPUT,0,0,		   // SessionID -	 35 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	from -	 36

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  // date	to -	 37
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,	   // ownerid  -	 38
*/
			};			

			
			hr = cmdBuildMergeUV.SetParameterInfo(5, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdBuildMergeUV.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdBuildMergeUV.m_vMergeFrom.vt = VT_DATE;
			cmdBuildMergeUV.m_vMergeTo.vt = VT_DATE;
			cmdBuildMergeUV.m_cRows = 0;
			cmdBuildMergeUV.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdBuildMergeUV.m_spCommand.p, sErr, hr, 
									"PrepareBuildMergeUV");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL BuildMergeUV(int iID, long lMergeFrom, long lMergeTo, char *sSessionID, ERRSTRUCT *pzErr)
{ 
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "BuildMergeUV", FALSE);
#endif

	*pzErr = PrepareBuildMergeUV();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		strcpy_s(cmdBuildMergeUV.m_sSessionID, sSessionID);
		cmdBuildMergeUV.m_iID = iID;
		SETVARDATE(cmdBuildMergeUV.m_vMergeTo,lMergeTo);
		SETVARDATE(cmdBuildMergeUV.m_vMergeFrom,lMergeFrom);

		hr = cmdBuildMergeUV.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec/Open";

		cmdBuildMergeUV.Close();
	} // try

	catch (char* sErr) 
	{
		*pzErr = PrintError("BuildMergeUV",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdBuildMergeUV.m_spCommand.p, sErr, hr, 
									"BuildMergeUV");
	} // catch

}//BuildMergeUV
//****************************************************************


#define GetSummarizedDataForCompositeEx_SQL_Reset "DELETE FROM Merge_SData WITH (ROWLOCK) WHERE SessionID = ? \n\0"
#define GetSummarizedDataForCompositeEx_SQL_000 "exec dbo.usp_WtdAverageMerge_sData ?, ?, ? \n\0"

/*
#define GetSummarizedDataForCompositeEx_SQL_000 "INSERT INTO Merge_SData WITH (ROWLOCK) \n\
	(SessionID, Portfolio_ID, ID, Perform_Date, ActualDate, \n\
	Mkt_Val, Book_value, Accr_Inc, Accr_Div, Inc_rclm, Div_rclm, \n\
	Net_Flow, Wtd_flow, Purchases, Sales, Income, Wtd_inc, Fees, Wtd_Fees, \n\
	Exch_Rate_Base, PrincipalPayDown, Maturity, Contributions, Withdrawals, \n\
	Expenses, Receipts, IncomeCash, PrincipalCash, FeesOut, Transfers, \n\
	TransferIn, TransferOut, EstAnnIncome, Perform_Type, NotionalFlow, GWF, NWF, \n\
	Wtd_Income, Wtd_Fedetax_Inc, Wtd_Fedatax_Inc, Wtd_Fedtax_Rclm, Wtd_Fedinctax_Wthld, \n\
	Fedetax_Accr_Inc, Fedatax_Accr_Inc, Fedetax_Accr_Div, Fedatax_Accr_Div, Src) \n\0"
*/
#define GetSummarizedDataForCompositeEx_SQL_001 "SELECT smm.SessionID, \n\
		sd.portfolio_id, sd.id, sd.perform_date, sd.perform_date, \n\
		CASE WHEN mkt_val < -1e+308 THEN 0 ELSE mkt_val END, \n\
		Book_value, Accr_inc, Accr_Div, Inc_rclm, Div_rclm, \n\
		Net_Flow, Wtd_flow, Purchases, Sales, Income, Wtd_inc, Fees, Wtd_Fees, \n\
		sd.Exch_rate_base, 	PrincipalPayDown, Maturity, Contributions, Withdrawals, \n\
		Expenses, Receipts, IncomeCash, PrincipalCash, FeesOut, Wtd_FeesOut, Transfers, \n\
		TransferIn, TransferOut, EstAnnIncome,  Perform_Type,NotionalFlow, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_002 " \n\
		CASE sd.Perform_type WHEN 'I' THEN net_flow -  fees ELSE wtd_flow - wtd_fees  END, \n\
		CASE sd.Perform_type WHEN 'I' THEN net_flow ELSE wtd_flow END, \n\
		CASE WHEN sd.portfolio_id =  sd.id THEN 0 \n\
       ELSE CASE sd.Perform_type WHEN 'I' THEN income ELSE wtd_inc END END, \n\
		CASE sd.Perform_type WHEN 'I' THEN ISNULL(Fedetax_Inc,0) \n\
       ELSE ISNULL(Wtd_Fedetax_Inc,0) END, \n\
		CASE sd.Perform_type WHEN 'I' THEN ISNULL(Fedatax_Inc,0) \n\
       ELSE ISNULL(Wtd_Fedatax_Inc,0) END, \n\
		CASE sd.Perform_type WHEN 'I' THEN ISNULL(Fedtax_Rclm,0) \n\
       ELSE ISNULL(Wtd_Fedtax_Rclm,0) END, \n\
		CASE sd.Perform_type WHEN 'I' THEN ISNULL(Fedinctax_Wthld,0) \n\
       ELSE ISNULL(Wtd_Fedinctax_Wthld,0) END, \n\
		ISNULL(Fedetax_Accr_Inc, 0), \n\
		ISNULL(Fedatax_Accr_Inc, 0), \n\
		ISNULL(Fedetax_Accr_Div, 0), \n\
ISNULL(Fedatax_Accr_Div, 0), 'O' as src, Cons_fee, ISNULL(Wtd_cons, 0) Wtd_Cons \n\0"

// will have to construct proper query for SUMMDATA vs. DSUMDATA
// and be carefull with parameters
#define GetSummarizedDataForCompositeEx_SQL_004a "FROM \n\
		(SELECT DISTINCT membersegid, memberportid, SessionID \n\
				FROM Merge_CompSegMap WHERE SessionID = ? ) smm \n\0"
		
#define GetSummarizedDataForCompositeEx_SQL_004_01_SUMMDATA "JOIN summdata \n\
		sd ON sd.id = smm.membersegid\n\
         AND sd.perform_date >= ? AND sd.perform_date <= ? \n\0"

#define GetSummarizedDataForCompositeEx_SQL_004_01_DSUMDATA "JOIN dsumdata \n\
		sd ON sd.id = smm.membersegid \n\
         AND sd.perform_date = ? \n\0"

#define GetSummarizedDataForCompositeEx_SQL_004c "LEFT OUTER \n\
 	 JOIN taxperf tp ON tp.portfolio_ID = sd.Portfolio_ID and tp.id = sd.id \n\
   AND tp.perform_date = sd.perform_date \n\0"

#define GetSummarizedDataForCompositeEx_SQL_004_02_DSUMDATA "WHERE NOT EXISTS \n\
	(SELECT * FROM Merge_SData sd1 \n\
	WHERE sd1.id = sd.id \n\
	AND sd1.perform_date = sd.perform_date AND smm.SessionID = sd1.SessionID)\n\0"

/**** Updating for terminated records *** */
/*  Old update for terminate was to set weighted flows to 0 - now reweight for period
#define GetSummarizedDataForCompositeEx_SQL_005 "UPDATE Merge_SData WITH (ROWLOCK) SET \n\
	Wtd_Flow = 0, GWF = 0, NWF = 0, Wtd_Inc = 0, Wtd_Fedetax_Inc = 0, \n\
	Wtd_Fedatax_Inc = 0, Wtd_Fedinctax_Wthld = 0, Wtd_FedTax_Rclm = 0 \n\
   WHERE SessionID = ? AND Perform_Date > ? \n\
   AND (perform_type='T' OR (mkt_val + accr_inc + accr_div = 0)) \n\
   AND NOT EXISTS \n\
   (SELECT * FROM Merge_SData sdi \n\
   WHERE sdi.SessionID = Merge_SData.SessionID \n\
   AND sdi.portfolio_id = Merge_SData.portfolio_id \n\
   AND sdi.id = Merge_SData.id \n\
   AND  sdi.perform_date < Merge_SData.perform_date \n\
   AND sdi.perform_type='I' AND sdi.Perform_Date > ? ) \n\0"
*/


#define GetSummarizedDataForCompositeEx_SQL_005 "UPDATE Merge_SData WITH (ROWLOCK) SET \n\
	Wtd_Flow = TT.Net_Flow * ReweightFactor, \n\
    GWF = (TT.Net_Flow - TT.Fees) * ReweightFactor, \n\
	NWF = (TT.Net_Flow + TT.feesout) * ReweightFactor, \n\
    CNWF = (TT.Net_Flow - (TT.fees- TT.Cons_Fee) * ReweightFactor, \n\
	Wtd_Inc = TT.Wtd_Inc * ReweightFactor, \n\
	Wtd_Fedetax_Inc = TT.Wtd_Fedetax_Inc * ReweightFactor, \n\
	Wtd_Fedatax_Inc = TT.Wtd_Fedatax_Inc * ReweightFactor, \n\
	Wtd_Fedinctax_Wthld = TT.Wtd_Fedinctax_Wthld * ReweightFactor, \n\
	Wtd_FedTax_Rclm = TT.Wtd_FedTax_Rclm * ReweightFactor, \n\
	Perform_Type = 'W' \0"

#define GetSummarizedDataForCompositeEx_SQL_005a "FROM ( \n\
	SELECT Convert(FLOAT, DATEDIFF(DD, perform_date,?))/Convert(Float, (DATEDIFF(DD, ?, ?)+ExtraDaysCnt)) \n\
		AS ReweightFactor, * FROM ( \n\
		SELECT (SELECT MIN(perform_date) \n\
		FROM Merge_Sdata SD2 WITH (ROWLOCK) \n\
						WHERE sd2.portfolio_id = sd.portfolio_id AND sd2.id = sd.id \n\
               AND sd2.perform_date > sd.perform_date) AS EndSubPeriodDate, \n\
						(SELECT CASE Flow_Weight_Method WHEN 0 THEN 0 WHEN 1 THEN 1 WHEN 2 THEN 0.5 ELSE 0 END \n\
						FROM syssetng) AS ExtraDaysCnt, * \n\
FROM Merge_SData sd WITH (READPAST, UPDLOCK) \0"

#define GetSummarizedDataForCompositeEx_SQL_005b " WHERE SessionID = ? AND (perform_type='T' ) \n\
	AND ((Perform_date <> ?) or (wtd_flow = 0)) AND EXISTS \n\
	(SELECT * FROM summdata csd, Merge_CompSegMap csm WITH (ROWLOCK) \n\
         WHERE  csd.id = csm.id AND csm.membersegid = sd.id AND csd.perform_date = ? \n\
          AND csm.SessionID = sd.SessionID ) \n\
	) T ) TT \n\
	WHERE TT.SessionID = Merge_SData.SessionID AND TT.Portfolio_ID = Merge_SData.Portfolio_ID \n\
	AND TT.ID = Merge_SData.ID AND TT.Perform_Date = Merge_SData.Perform_Date \n\0"
 
#define GetSummarizedDataForCompositeEx_SQL_005c "UPDATE Merge_SData WITH (ROWLOCK) SET \n\
		mkt_val = 0, Book_value = 0, Accr_inc = 0, Accr_Div = 0, \n\
		Inc_rclm = 0, Div_rclm = 0 \n\
	WHERE SessionID = ? AND perform_date > ? AND EXISTS \n\
		(SELECT sd2.* FROM Merge_SData sd1 \n\
			JOIN Merge_Compsegmap AS mc on mc.Sessionid = sd1.sessionid AND mc.MemberSegID = sd1.id \n\
			JOIN Merge_CompSegmap as mc2 on mc2.sessionid = mc.sessionid and mc2.SegmentType_ID = mc.SegmentType_ID \n\
			JOIN Merge_SData as sd2  on sd2.sessionid = mc2.sessionid and sd2.id = mc2.MemberSegID \n\
			WHERE sd1.SessionID = Merge_SData.SessionID \n\
			AND sd1.portfolio_id = Merge_SData.portfolio_id \n\
			AND sd1.id = Merge_SData.id AND Merge_SData.perform_date < sd2.perform_date) \n\0"

#define GetSummarizedDataForCompositeEx_SQL_005d "UPDATE Merge_SData WITH (ROWLOCK) SET \n\
	Wtd_Flow = TT.GWF * ReweightFactor, \n\
	GWF =TT.GWF*ReweightFactor,NWF =TT.NWF*ReweightFactor, \n\
	CNWF =TT.CNWF*ReweightFactor,Wtd_Inc = TT.Wtd_Inc * ReweightFactor, \n\
	Wtd_Fedetax_Inc = TT.Wtd_Fedetax_Inc * ReweightFactor, \n\
	Wtd_Fedatax_Inc = TT.Wtd_Fedatax_Inc * ReweightFactor, \n\
	Wtd_Fedinctax_Wthld = TT.Wtd_Fedinctax_Wthld * ReweightFactor, \n\
	Wtd_FedTax_Rclm = TT.Wtd_FedTax_Rclm * ReweightFactor, \n\
	Perform_Type = 'W' \n\0"
	
#define GetSummarizedDataForCompositeEx_SQL_005e "FROM ( \n\
	SELECT convert(float, DATEDIFF(DD, perform_date, ?))/(Convert(Float, DATEDIFF(DD, ?, ?)+ExtraDaysCnt)) \n\
		AS ReweightFactor, * FROM ( \n\
		SELECT (SELECT MIN(perform_date) \n\
						FROM Merge_Sdata SD2 \n\
						WHERE sd2.portfolio_id = sd.portfolio_id AND sd2.id = sd.id \n\
               AND sd2.perform_date > sd.perform_date) AS EndSubPeriodDate, \n\
						(SELECT CASE Flow_Weight_Method WHEN 0 THEN 0 WHEN 1 THEN 1 WHEN 2 THEN 0.5 ELSE 0 END \n\
						FROM syssetng) AS ExtraDaysCnt, * \n\0"

#define GetSummarizedDataForCompositeEx_SQL_005f "FROM Merge_SData sd \n\
	WHERE SessionID = ? AND perform_type='I' AND EXISTS \n\
	(SELECT * FROM summdata csd, Merge_CompSegMap csm \n\
   WHERE  csd.id = csm.id AND csm.membersegid = sd.id AND csd.perform_date = ? \n\
   AND csm.SessionID = sd.SessionID ) \n\
	) T ) TT \n\
	WHERE TT.SessionID = Merge_SData.SessionID AND TT.Portfolio_ID = Merge_SData.Portfolio_ID \n\
	AND TT.ID = Merge_SData.ID AND TT.Perform_Date = Merge_SData.Perform_Date \n\0"


#define GetSummarizedDataForCompositeEx_SQL_006 "SELECT SessionID, \n\
		portfolio_id, sd.id, ActualDate AS perform_date, (ActualDate), \n\
		SUM(Mkt_val), SUM(Book_value), SUM(Accr_inc), SUM(Accr_Div), SUM(Inc_rclm), SUM(Div_rclm), \n\
		SUM(Net_Flow), SUM(Wtd_flow), SUM(Purchases), SUM(Sales),	SUM(Income), SUM(Wtd_inc), \n\
		SUM(Fees), SUM(Wtd_Fees), MAX(Exch_rate_base), SUM(PrincipalPayDown), \n\
		SUM(Maturity), SUM(Contributions), SUM(Withdrawals), SUM(Expenses), SUM(Receipts), \n\
		SUM(IncomeCash), SUM(PrincipalCash), SUM(FeesOut), SUM(Wtd_FeesOut), SUM(Transfers), \n\
		SUM(TransferIn), SUM(TransferOut), SUM(EstAnnIncome),  MAX(Perform_Type), SUM(NotionalFlow), SUM(GWF), SUM(NWF), \n\
		SUM(Wtd_Income), SUM(Wtd_Fedetax_Inc), SUM(Wtd_Fedatax_Inc), \n\
		SUM(Wtd_Fedtax_Rclm), SUM(Wtd_Fedinctax_Wthld), \n\
0, 0,	0, 0, 'S' AS src, sum(CNWF), sum(ISNULL(Wtd_cons, 0)) \n\
	FROM Merge_SData sd \n\
	WHERE SessionID = ?	AND perform_date > ? AND perform_date <= ? \n\
	GROUP BY SessionID, ActualDate, portfolio_id, id \n\0"

#define GetSummarizedDataForCompositeEx_SQL_006a "UPDATE Merge_SDATA WITH (ROWLOCK) \n\
	SET Mkt_val = 0, Accr_inc = 0, Accr_div = 0 \n\
	WHERE SessionID = ? AND Perform_date < ? and Perform_date > ? and (DATEDIFF(DD, ?, ?) > 33)  \n\0"

#define GetSummarizedDataForCompositeEx_SQL_007 "DELETE FROM Merge_SData WITH (ROWLOCK) \n\
	WHERE SessionID = ? AND perform_date > ? AND perform_date <= ? AND src = 'O' \n\0"
  
#define GetSummarizedDataForCompositeEx_SQL_008 "SELECT sm.id as id, \n\
  ISNULL(uvc.unitvalue,100)*(CROR/100 + 1) AS EUV, \n\
		CASE WHEN uvc.stream_begin_date IS NOT NULL then 4 \n\
				 WHEN ABS(emv) < 0.01 THEN 7 \n\
				 WHEN SBD > ? THEN 2 \n\
         WHEN SBD < pm.inceptiondate THEN 2 ELSE 1 END AS ror_source, \n\
  ISNULL(uvc.stream_begin_date, \n\
    CASE WHEN SBD > ? THEN SBD \n\
         WHEN SBD < pm.inceptiondate THEN pm.inceptiondate \n\
         ELSE ? END) AS SBD, \n\
  TTT.segmenttype_id, TTT.ror_type, perform_date, \n\
  nflow,  Wtd_Flow, Mkt_val, Book_value, Accr_inc, Accr_Div, \n\
  Purchases, Sales, TTT.income, Wtd_inc, \n\
  Fees, Wtd_Fees, PrincipalPayDown, TTT.Maturity, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_009 "Contributions - \n\
	(SELECT ISNULL(SUM(amount),0) FROM bankstat b1 WITH (NOLOCK) \n\
	WHERE TransactionCode_ID IN (24) \n\
	AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND tdate > ? AND tdate <= ? \n\
	AND EXISTS (SELECT * FROM bankstat b2  WITH (NOLOCK) \n\
		WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
		AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
		AND b2.TransactionCode_ID in (25) \n\
	)) as Contributions, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_010 "Withdrawals - \n\
	(SELECT ISNULL(SUM(amount),0) FROM bankstat b1 WITH (NOLOCK)  \n\
	WHERE TransactionCode_ID IN (25) \n\
	AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND tdate > ? AND tdate <= ? \n\
	AND EXISTS (SELECT * FROM bankstat b2  WITH (NOLOCK) \n\
		WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
		AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount)<0.01 \n\
		AND b2.TransactionCode_ID IN (24) \n\
	)) as Withdrawals, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_011 "Expenses, Receipts, \n\
  IncomeCash, PrincipalCash, FeesOut, Wtd_FeesOut, \n\
  Transfers, TransferIn, TransferOut, EstAnnIncome,cror, NotionalFlow, Perform_type,\n\
  cons_fee, ISNULL(Wtd_cons, 0) Wtd_Cons FROM ( \n\0"

#define GetSummarizedDataForCompositeEx_SQL_012 "SELECT \n\
	segmenttype_id, ror_type, max(ActualDate) perform_date, MIN(SBD) AS SBD, \n\
  CASE WHEN ABS(SUM(WMV)) < 1e-18 THEN 0 ELSE CASE WHEN (SUM(WMV) >=0 or sum(BMV)=0) THEN SUM(WROR)/SUM(WMV)*100  \n\
  ELSE  ((SUM(WROR)/SUM(WMV)*100) * -1 )  END END AS CROR, \n\
  SUM(ROR)/count(*)*100 AS CRORAvg, SUM(BMV) AS BMV, SUM(EMV) AS EMV, SUM(NF) AS NFLOW, \n\
  SUM(Income) AS income, SUM(Fees) AS Fees, SUM(mkt_val) AS Mkt_val, SUM(Book_value) AS Book_value, \n\
  SUM(Accr_inc) AS Accr_inc, SUM(Accr_Div) AS Accr_Div, SUM(Purchases) AS Purchases, SUM(Sales) AS Sales, \n\
  SUM(Wtd_inc) AS Wtd_inc, SUM(Wtd_Fees) AS Wtd_Fees,  SUM(PrincipalPayDown) AS PrincipalPayDown, \n\
	SUM(Maturity) AS Maturity, SUM(Contributions) AS Contributions, SUM(Withdrawals) AS Withdrawals, \n\
  SUM(Expenses) AS Expenses, SUM(Receipts) AS Receipts, SUM(IncomeCash) AS IncomeCash, \n\
	SUM(PrincipalCash) AS PrincipalCash, SUM(FeesOut) AS FeesOut, SUM(Wtd_FeesOut) AS Wtd_FeesOut, SUM(Transfers) AS Transfers, \n\
  SUM(TransferIn) AS TransferIn, SUM(TransferOut) AS TransferOut,SUM(NotionalFlow) as NotionalFlow, \n\
  SUM(EstAnnIncome) AS EstAnnIncome, SUM(WMV) AS wmv, SUM(Wtd_flow) AS Wtd_Flow, max(Perform_type) Perform_type, \n\
  SUM(cons_fee) Cons_fee, Sum(ISNULL(Wtd_Cons,0)) Wtd_Cons \n\0"

#define GetSummarizedDataForCompositeEx_SQL_013 "FROM ( \n\
	SELECT   \n\
	CASE WHEN WeightFactor >=0.0 THEN WeightFactor * (EUV/BUV-1.0) ELSE \n\
	CASE WHEN (EUV/BUV -1) = -1.0 OR ((EMV -NF- (EUV/BUV - 1.0) * wtd_flow)/((EUV/BUV-1.0)+1)) *-1 = Wtd_flow  \n\
	THEN WeightFactor * (euv/buv-1) * -1.0 ELSE \n\
	CASE WHEN bmv=0.0 AND ROUND((EMV-((EMV-NF-(EUV/BUV - 1.0) * wtd_flow)/ ((EUV/BUV-1.0)+ 1))- NF) / (((EMV - NF-(EUV/BUV - 1.0) * wtd_flow) / \n\
	((EUV/BUV - 1.0)+1))+ wtd_flow),1)=ROUND((euv/buv-1.0),1) \n\
	AND ((EMV -NF - (EUV/BUV-1.0) * wtd_flow)/((EUV/BUV-1.0)+1))>0.0 THEN \n\
	WeightFactor * (euv/buv - 1.0)  ELSE WeightFactor * (EUV/BUV - 1.0) *  -1.0  END END END AS WROR, \n\
	WeightFactor AS WMV,(EUV/BUV - 1) AS ROR, *  \n\0"

#define GetSummarizedDataForCompositeEx_SQL_013a "FROM (SELECT \n\
	CASE ror_type/100 \n\
	WHEN 3 THEN \n\
		CASE WHEN EUV = -999 AND FudgeFactor <> 0 THEN 0 ELSE 1 END \n\
	WHEN 2 THEN  \n\
		CASE WHEN EUV = -999 AND FudgeFactor <> 0 THEN 0 ELSE BMV END \n\
	ELSE \n\
		CASE WHEN EUV = -999 AND FudgeFactor <> 0 THEN 0  \n\
		ELSE CASE WHEN ABS(BMV+WF) < 0.01 AND ABS(EUV-BUV)>0.0001*BUV AND BMV <> 0 \n\
      			THEN CASE WHEN Perform_Type='W' THEN 0 \n\
		          WHEN NF<>0 THEN NF ELSE CASE WHEN (ABS(EUV-BUV) > 0) then (ABS(EMV  / ((EUV/BUV - 1)*100))/2 ) ELSE 0 END END  \n\
			     ELSE BMV+WF END END \n\
	END AS WeightFactor, *  \n\
	FROM ( SELECT \n\
		sm.segmenttype_id, sd.ActualDate, sd.Perform_date, rt.id ror_type, \n\
		ISNULL((SELECT CASE WHEN mkt_val < -1e+308 THEN NULL ELSE \n\
			CASE WHEN rt.id % 100  IN (1,3) THEN mkt_val+ accr_inc + accr_div \n\
           WHEN rt.id % 100  IN (2,4,5) THEN mkt_val \n\
           WHEN rt.id % 100  IN (8,9) \n\
               THEN mkt_val+ accr_inc + (Fedetax_Accr_Inc / sm.taxrate - Fedetax_Accr_Inc) \n\
                    + accr_div + (Fedetax_Accr_Div / sm.taxrate - Fedetax_Accr_Div) \n\
           WHEN rt.id % 100  IN (10,11) \n\
               THEN mkt_val+ accr_inc + (Fedatax_Accr_Inc * sm.taxrate - Fedatax_Accr_Inc) \n\
                    + accr_div + (Fedatax_Accr_Div * sm.taxrate - Fedatax_Accr_Div) \n\
           ELSE mkt_val+ accr_inc + accr_div END END \n\
      FROM Merge_SData m1 WITH (NOLOCK)  \n\
      WHERE m1.id = sd.id AND m1.portfolio_id = sd.portfolio_id  \n\
	  AND m1.SegmentTypeID = sd.SegmentTypeID \n\
      AND m1.perform_date = (SELECT ISNULL(MIN(sdm.Perform_date),?) FROM Merge_SData sdm  WITH (NOLOCK)   \n\
						WHERE sessionid = m1.SessionID and m1.SegmentTypeID = sdm.SegmentTypeID \n\
						AND sdm.Perform_Date >= ?) AND m1.SessionID = ? \n\
    ),0) AS BMV, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_013b " ISNULL(CASE WHEN mkt_val < -1e+308 THEN NULL ELSE \n\
	mkt_val+ accr_inc + accr_div END, 0)  AS EMV, \n\0"

// 2006-05-16 vay		
// According to GIPS US After Tax guidance document (page 13), taxes should not be included 
// in the portfolio flow adjustment in the denominator (taxes are an expense but formulae assume
// that cash is not withdrawn from the account in order to pay the taxes)
// Performance.DLL has been modified to handle this requirement on individual accounts
// Here is the change for Composites - when doing BMV + WF weighting,
// WF does not include tax adjustments anymore

#define GetSummarizedDataForCompositeEx_SQL_014 "net_flow AS NF,  wtd_flow, \n\
CASE rt.id % 100  \n\
		WHEN 1 THEN GWF \n\
    WHEN 2 THEN GWF + Wtd_Inc \n\
    WHEN 3 THEN NWF \n\
    WHEN 4 THEN NWF + Wtd_Inc \n\
    WHEN 5 THEN 0 \n\
    WHEN 8 THEN GWF\n\
    WHEN 9 THEN NWF\n\
    WHEN 10 THEN GWF\n\
    WHEN 11 THEN NWF\n\
    WHEN 12 THEN CNWF\n\
    ELSE GWF END AS WF, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_015 "Mkt_val, \n\
	Book_value, Accr_inc, Accr_Div, \n\
	Purchases, Sales, Income, Wtd_inc, \n\
	Fees, Wtd_Fees, PrincipalPayDown, Maturity, \n\
	Contributions, Withdrawals, Expenses, Receipts, \n\
	IncomeCash, PrincipalCash, FeesOut, Wtd_FeesOut, NotionalFlow, \n\
	Transfers, TransferIn, TransferOut, EstAnnIncome, Perform_Type, \n\
	ISNULL(NULLIF((SELECT TOP 1 u1.unitvalue  \n\
		FROM Merge_UV u1 WITH (NOLOCK)  \n\
    WHERE u1.SessionID = uv.SessionID  \n\
    AND u1.id = uv.id AND u1.portfolio_id = uv.portfolio_id \n\
	AND u1.ror_type = uv.ror_type \n\
    AND u1.stream_begin_date = uv.stream_begin_date \n\
    AND uvdate >= ? \n\
    AND uvdate < ? \n\
    AND u1.SegmentTypeID = uv.SegmentTypeID \n\
    AND ror_source in (1,2,3,4,6,7) \n\
    ORDER BY uvdate),0),100) AS BUV, \n\0"

// baduv - so I dont have to back out the parameter for u1.uvdate >=?
#define GetSummarizedDataForCompositeEx_SQL_015a " ISNULL(uv.stream_begin_date, sd.ActualDate) AS SBD ,\n\
	ISNULL(NULLIF((SELECT TOP 1 u1.unitvalue  \n\
		FROM Merge_UV u1 WITH (NOLOCK)  \n\
    WHERE u1.SessionID = uv.SessionID  \n\
    AND u1.id = uv.id AND u1.portfolio_id = uv.portfolio_id \n\
	AND u1.ror_type = uv.ror_type \n\
    AND u1.stream_begin_date = uv.stream_begin_date \n\
    AND u1.SegmentTypeID = uv.SegmentTypeID \n\
    and u1.uvdate >= ? --datefrom \n\
    AND ror_source in (1,2,3,4,6,7) \n\
    ORDER BY uvdate desc),0),-999) AS badUV, \n\
    unitvalue as EUV,\n\
Fudge_Factor AS FudgeFactor,Cons_fee, ISNULL(Wtd_cons,0) Wtd_Cons \n\0"
 
#define GetSummarizedDataForCompositeEx_SQL_016 "FROM Merge_CompSegMap sm  WITH (NOLOCK)\n\
	JOIN (SELECT id FROM rtntype WITH (NOLOCK) WHERE lookuptype = 5 AND id NOT IN (6,7) \n\
			UNION SELECT 0 AS id) rt ON 1=1 \n\
	JOIN Merge_SData sd WITH (NOLOCK)  \n\
		ON sd.id = sm.membersegid \n\
		AND sd.SegmentTypeid = sm.SegmentType_ID \n\
		AND perform_date > ? AND perform_date <= ? \n\
		AND Perform_date = (select max(Perform_date) from Merge_sdata WITH (NOLOCK)  \n\
							where Sessionid = sd.Sessionid \n\
							AND segmenttypeid = sd.segmenttypeid) \n\
		AND sd.SessionID = sm.SessionID \n\
	LEFT OUTER JOIN Merge_UV uv WITH (NOLOCK)  \n\
	ON uv.SessionID = sm.SessionID \n\
	AND uv.id = sd.id \n\
    AND uv.SegmenttypeID = sd.SegmentTypeid \n\
	AND uv.uvdate = sd.perform_date AND rt.id = uv.ror_type \n\
	WHERE sm.SessionID = ?  \n\
    AND (rt.id = uv.ror_type OR rt.id=0) \n\
	) S ) T ) TT \n\
	GROUP BY segmenttype_id, ror_type, actualdate \n\
	) TTT \n\
	JOIN portmain pm WITH (NOLOCK)  ON pm.id = ? AND deletedate IS NULL AND portfoliotype IN (1,6,7) \n\0"

//in statement above the where statement negates the left outer join on merge_UV .. = uv.ror_type, excluding terminating/mid period cat changes

#define GetSummarizedDataForCompositeEx_SQL_017 "LEFT OUTER JOIN \n\
	(SELECT DISTINCT id, segmenttype_id, owner_id, SessionID \n\
	FROM Merge_CompSegMap  WITH (NOLOCK) WHERE SessionID = ?) sm \n\
        ON owner_id = pm.id AND sm.segmenttype_id = TTT.segmenttype_id \n\
	LEFT OUTER JOIN Merge_UV uvc WITH (NOLOCK)  ON uvc.SessionID = sm.SessionID \n\
	AND uvc.id = sm.id \n\
    AND uvc.ror_type = TTT.ror_type AND uvdate >= ? \n\
    AND uvdate < TTT.Perform_Date AND ror_source IN (1,2,3,4,6,7) \n\
	WHERE perform_date IS NOT NULL AND (croravg IS NOT NULL OR TTT.ror_type = 0) \n\0"


//*** union all ***/

#define GetSummarizedDataForCompositeEx_SQL_018 "UNION ALL SELECT sm.id as id,  \n\
  100.0 AS EUV,  4 as ror_source, Perform_date as SBD,   TTT.segmenttype_id,\n\
   TTT.ror_type, perform_date, nflow,  Wtd_Flow, Mkt_val, Book_value, \n\
  Accr_inc, Accr_Div, Purchases, Sales, TTT.income, Wtd_inc, Fees, Wtd_Fees, PrincipalPayDown, \n\
  TTT.Maturity, \n\0"
 
#define GetSummarizedDataForCompositeEx_SQL_019 "Contributions - \n\
	(SELECT ISNULL(SUM(amount),0) FROM bankstat b1 WITH (NOLOCK)  \n\
	WHERE TransactionCode_ID IN (24) \n\
	AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND tdate > ? AND tdate <= ? \n\
	AND EXISTS (SELECT * FROM bankstat b2 WITH (NOLOCK)  \n\
		WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
		AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
		AND b2.TransactionCode_ID in (25) \n\
	)) as Contributions, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_020 "Withdrawals - \n\
	(SELECT ISNULL(SUM(amount),0) FROM bankstat b1  WITH (NOLOCK) \n\
	WHERE TransactionCode_ID IN (25) \n\
	AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2  WITH (NOLOCK) \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK) \n\
                WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
	AND tdate > ? AND tdate <= ? \n\
	AND EXISTS (SELECT * FROM bankstat b2  WITH (NOLOCK) \n\
		WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
		AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount)<0.01 \n\
		AND b2.TransactionCode_ID IN (24) \n\
	)) as Withdrawals, \n\0"

#define GetSummarizedDataForCompositeEx_SQL_021 "Expenses, Receipts, \n\
  IncomeCash, PrincipalCash, FeesOut, Wtd_FeesOut, \n\
Transfers, TransferIn, TransferOut, EstAnnIncome, 0.0 cror, NotionalFlow, perform_type, cons_fee, ISNULL(Wtd_Cons,0) FROM ( \n\0"

#define GetSummarizedDataForCompositeEx_SQL_022 "SELECT Owner_ID, \n\
	segmenttype_id, ror_type, perform_date, SUM(Net_Flow) AS NFLOW, \n\
	SUM(Income) AS income, SUM(Fees) AS Fees, SUM(mkt_val) AS Mkt_val, SUM(Book_value) AS Book_value, \n\
	SUM(Accr_inc) AS Accr_inc, SUM(Accr_Div) AS Accr_Div, SUM(Purchases) AS Purchases, SUM(Sales) AS Sales, \n\
	SUM(Wtd_inc) AS Wtd_inc, SUM(Wtd_Fees) AS Wtd_Fees,  SUM(PrincipalPayDown) AS PrincipalPayDown, \n\
	SUM(Maturity) AS Maturity, SUM(Contributions) AS Contributions, SUM(Withdrawals) AS Withdrawals, \n\
	SUM(Expenses) AS Expenses, SUM(Receipts) AS Receipts, SUM(IncomeCash) AS IncomeCash, \n\
	SUM(PrincipalCash) AS PrincipalCash, SUM(FeesOut) AS FeesOut, SUM(Wtd_FeesOut) AS Wtd_FeesOut, SUM(Transfers) AS Transfers, \n\
	SUM(TransferIn) AS TransferIn, SUM(TransferOut) AS TransferOut,SUM(NotionalFlow) as NotionalFlow, \n\
	SUM(EstAnnIncome) AS EstAnnIncome, 0.0 AS wmv, SUM(Wtd_flow) AS Wtd_Flow, max(Perform_type) perform_type, \n\
    SUM(cons_fee) AS Cons_Fee, SUM(ISNULL(Wtd_Cons,0)) AS Wtd_Cons	\n\0"

//	JOIN (SELECT id FROM rtntype WHERE lookuptype = 5 AND id NOT IN (6,7) 

#define GetSummarizedDataForCompositeEx_SQL_025 " FROM Merge_CompSegMap sm WITH (NOLOCK)  \n\
	JOIN (SELECT 0 AS ror_type) rt ON 1=1 \n\
	JOIN Merge_SData sd WITH (NOLOCK)  \n\
		ON sd.id = sm.membersegid\n\
		AND sd.SegmentTypeid = sm.SegmentType_ID \n\
		AND sd.Perform_date = (SELECT MIN(Perform_date) from Merge_sdata WITH (NOLOCK)  \n\
							where Sessionid = sd.Sessionid \n\
							AND segmenttypeid = sd.segmenttypeid) \n\
		AND EXISTS (SELECT S.* FROM Merge_SData S WITH (NOLOCK)  where S.Sessionid = sd.Sessionid \n\
		AND S.segmenttypeid = sd.SegmentTypeID AND S.Perform_Date > sd.Perform_date) \n\
		AND sd.SessionID = sm.SessionID \n\
		AND SD.Perform_Date > ? AND SD.Perform_date < ?  \n\
		WHERE sm.SessionID = ? \n\
	GROUP BY owner_id , segmenttype_id, ror_type, perform_date \n\
	) TTT \n\
	JOIN portmain pm  WITH (NOLOCK) ON pm.id = TTT.Owner_ID AND deletedate IS NULL AND portfoliotype IN (1,6,7) \n\0"


#define GetSummarizedDataForCompositeEx_SQL_027 "LEFT OUTER JOIN \n\
	(SELECT DISTINCT id, segmenttype_id, owner_id, SessionID \n\
	FROM Merge_CompSegMap  WITH (NOLOCK) WHERE SessionID = ?) sm \n\
        ON sm.owner_id = pm.id AND sm.segmenttype_id = TTT.segmenttype_id \n\
		WHERE perform_date IS NOT NULL and TTT.ror_type = 0 \n\
ORDER BY TTT.segmenttype_id, TTT.ror_type desc, perform_date  desc \n\0"

 
//*** ***/







//	ORDER BY TTT.segmenttype_id, TTT.ror_type desc, perform_date DESC \n\0"

//*****************************************************************
class CGetSummarizedDataForCompositeEx : public CQuery
{
public:
// data elements
	SUMMDATA			m_zSummdata;
	UNITVALUE			m_zUV;
	SEGMAIN				m_zSegmain;
	VARIANT				m_vPerformDate;
	VARIANT				m_vStreamBeginDate;
	double				m_fROR;

	int					m_iID;
	VARIANT				m_vMergeTo;
	VARIANT				m_vMergeFrom;
	BOOL					m_bDaily;
	char					m_sSessionID[GUID_STR_SIZE+NT];

// parameter binding map
BEGIN_PARAM_MAP(CGetSummarizedDataForCompositeEx)
   COLUMN_ENTRY(1,	m_vMergeFrom) //008
   COLUMN_ENTRY(2,	m_vMergeFrom) //008
   COLUMN_ENTRY(3,	m_vMergeFrom) //008
   COLUMN_ENTRY(4,	m_vMergeFrom) //009

   COLUMN_ENTRY(5,	m_vMergeTo)   //009
   COLUMN_ENTRY(6,	m_vMergeFrom) //010
   COLUMN_ENTRY(7,	m_vMergeTo)	  //010
   COLUMN_ENTRY(8,	m_vMergeFrom) //013
   COLUMN_ENTRY(9,	m_vMergeFrom) //013
   COLUMN_ENTRY(10, m_sSessionID) //013
   COLUMN_ENTRY(11,	m_vMergeFrom) //015
   COLUMN_ENTRY(12,	m_vMergeTo)	  //015
   COLUMN_ENTRY(13,	m_vMergeFrom) //015a added 4/13/2018

   COLUMN_ENTRY(14,	m_vMergeFrom)  //016
   COLUMN_ENTRY(15,	m_vMergeTo)    //016
   COLUMN_ENTRY(16,	m_sSessionID)	//016
   COLUMN_ENTRY(17,	m_iID)			//016

   COLUMN_ENTRY(18,	m_sSessionID)	//017
   COLUMN_ENTRY(19,	m_vMergeFrom) //017

   COLUMN_ENTRY(20,	m_vMergeFrom)  //019
   COLUMN_ENTRY(21,	m_vMergeTo)    //019

   COLUMN_ENTRY(22,	m_vMergeFrom)  //020
   COLUMN_ENTRY(23,	m_vMergeTo)    //020


   COLUMN_ENTRY(24,	m_vMergeFrom)   //025
   COLUMN_ENTRY(25,	m_vMergeTo)    //020
   COLUMN_ENTRY(26,	m_sSessionID)	//025
   COLUMN_ENTRY(27,	m_sSessionID)	//027


END_PARAM_MAP()

// column binding map
BEGIN_COLUMN_MAP(CGetSummarizedDataForCompositeEx)
   COLUMN_ENTRY(1,	m_zSegmain.iID)
   COLUMN_ENTRY(2,	m_zUV.fUnitValue)
   COLUMN_ENTRY(3,	m_zUV.iRorSource)
   COLUMN_ENTRY(4,	m_vStreamBeginDate)
   COLUMN_ENTRY(5,	m_zSegmain.iSegmentTypeID)
   COLUMN_ENTRY(6,	m_zUV.iRorType)
   COLUMN_ENTRY(7,	m_vPerformDate)
   COLUMN_ENTRY(8,	m_zSummdata.fNetFlow)
   COLUMN_ENTRY(9,	m_zSummdata.fWtdFlow)
	 
   COLUMN_ENTRY(10,	m_zSummdata.fMktVal) 
   COLUMN_ENTRY(11,	m_zSummdata.fBookValue)
   COLUMN_ENTRY(12,	m_zSummdata.fAccrInc) 
   COLUMN_ENTRY(13,	m_zSummdata.fAccrDiv) 
					
   COLUMN_ENTRY(14,	m_zSummdata.fPurchases)
   COLUMN_ENTRY(15,	m_zSummdata.fSales)
   COLUMN_ENTRY(16,	m_zSummdata.fIncome) 
   COLUMN_ENTRY(17,	m_zSummdata.fWtdInc) 
					
   COLUMN_ENTRY(18,	m_zSummdata.fFees)
   COLUMN_ENTRY(19,	m_zSummdata.fWtdFees)
   COLUMN_ENTRY(20,	m_zSummdata.fPrincipalPayDown)
   COLUMN_ENTRY(21,	m_zSummdata.fMaturity)
					
   COLUMN_ENTRY(22,	m_zSummdata.fContribution)
   COLUMN_ENTRY(23,	m_zSummdata.fWithdrawals)
   COLUMN_ENTRY(24,	m_zSummdata.fExpenses)
   COLUMN_ENTRY(25,	m_zSummdata.fReceipts) 
					
   COLUMN_ENTRY(26,	m_zSummdata.fIncomeCash)
   COLUMN_ENTRY(27,	m_zSummdata.fPrincipalCash)
   COLUMN_ENTRY(28,	m_zSummdata.fFeesOut)
   COLUMN_ENTRY(29, m_zSummdata.fWtdFeesOut)

   COLUMN_ENTRY(30,	m_zSummdata.fTransfers)
   COLUMN_ENTRY(31,	m_zSummdata.fTransfersIn)
   COLUMN_ENTRY(32,	m_zSummdata.fTransfersOut)
   COLUMN_ENTRY(33,	m_zSummdata.fEstAnnIncome) 

   COLUMN_ENTRY(34,	m_fROR) 
   COLUMN_ENTRY(35,	m_zSummdata.fNotionalFlow) 
   COLUMN_ENTRY(36,	m_zSummdata.sPerformType) 
   COLUMN_ENTRY(37, m_zSummdata.fCNFees)
   COLUMN_ENTRY(38, m_zSummdata.fWtdCNFees)

END_COLUMN_MAP()

};

CCommand<CAccessor<CGetSummarizedDataForCompositeEx>, CRowset > cmdGetSummarizedDataForCompositeEx;


void BuildSQLForCompositeEx(void)
{
			strcpy_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, ANY_SQL_000);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_008);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_009);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_010);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_011);

			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_012);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_013);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
					GetSummarizedDataForCompositeEx_SQL_013a);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
					GetSummarizedDataForCompositeEx_SQL_013b); 
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_014);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_015);

			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_015a);
			
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_016);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_017);
 
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_018);
 
 			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_019);
 			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_020);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_021);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_022);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_025);
			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 GetSummarizedDataForCompositeEx_SQL_027);



			strcat_s(cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
						 SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
			FILE        *fp;
	    fp = fopen("compquery2.txt", "w");
			fprintf(fp, "%s", cmdGetSummarizedDataForCompositeEx.m_sAdjSQL);
			fclose(fp);
#endif
}

ERRSTRUCT PrepareGetSummarizedDataForCompositeEx(BOOL bDaily)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdGetSummarizedDataForCompositeEx.m_bPrepared || 
			cmdGetSummarizedDataForCompositeEx.m_bDaily != bDaily)
  {
		if (cmdGetSummarizedDataForCompositeEx.m_bPrepared)
		{
				cmdGetSummarizedDataForCompositeEx.Close();
				cmdGetSummarizedDataForCompositeEx.Unprepare();
				cmdGetSummarizedDataForCompositeEx.m_bPrepared = false;
				cmdGetSummarizedDataForCompositeEx.ReleaseCommand();
		}

		cmdGetSummarizedDataForCompositeEx.m_bDaily = bDaily;

		try 
		{
  		BuildSQLForCompositeEx();
			
			hr = cmdGetSummarizedDataForCompositeEx.Create(dbSession, 
														cmdGetSummarizedDataForCompositeEx.m_sAdjSQL, 
														DBGUID_SQL);

 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, 17,18,19,20,21,22,23,24,25,26,27};
			DBPARAMBINDINFO	ParamInfo[27] = 
			{L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 1
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 2
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 3
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 4

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 - 5
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 6
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 - 7
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 8
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 9
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 10

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 11
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	TO-	 12
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from- 13

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from-	14

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 - 15

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 16
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,			 
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), //compid- 17
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 18

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,		// date from - 19 

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 20
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	TO-	 21
			 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 22
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	TO-	 23

			 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from-	24
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	TO-	 25

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 26
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0	// SessionID - 27
			};			

			hr = cmdGetSummarizedDataForCompositeEx.SetParameterInfo(27, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdGetSummarizedDataForCompositeEx.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdGetSummarizedDataForCompositeEx.m_cRows = 0;
			cmdGetSummarizedDataForCompositeEx.m_vMergeFrom.vt = VT_DATE;
			cmdGetSummarizedDataForCompositeEx.m_vMergeTo.vt = VT_DATE;
			cmdGetSummarizedDataForCompositeEx.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdGetSummarizedDataForCompositeEx.m_spCommand.p, sErr, hr, 
								"PrepareGetSummarizedDataForCompositeEx");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL GetSummarizedDataForCompositeEx(SEGMAIN	*pzSegmain,
											SUMMDATA  *pzSummdata, 
											UNITVALUE *pzUV, double *pfROR,
											int iID, long lMergeFrom, long lMergeTo,
											BOOL bDaily, char *sSessionID, 
											ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "GetSummarizedDataForCompositeEx", FALSE);
#endif
		*pzErr = PrepareGetSummarizedDataForCompositeEx(bDaily);
	if (pzErr->iSqlError != 0)
		return;

	try  
	{


		 
#ifdef DEBUG
			FILE        *fp;
	    fp = fopen("compfqury.txt", "w");
			fprintf(fp, "%s", cmdGetSummarizedDataForCompositeEx.m_sAdjSQL);
			fclose(fp);
#endif
			 

		// if subsequent call - get next record
		// if new params - close/open query
		if (!(cmdGetSummarizedDataForCompositeEx.m_iID == iID && 
					cmdGetSummarizedDataForCompositeEx.m_vMergeTo.date == lMergeTo && 
					cmdGetSummarizedDataForCompositeEx.m_vMergeFrom.date == lMergeFrom && 
					(strcmp(cmdGetSummarizedDataForCompositeEx.m_sSessionID, sSessionID) == 0) && 
			  cmdGetSummarizedDataForCompositeEx.m_cRows > 0))
		{
			cmdGetSummarizedDataForCompositeEx.m_cRows = 0;
			cmdGetSummarizedDataForCompositeEx.Close();
			
			cmdGetSummarizedDataForCompositeEx.m_iID = iID;
			SETVARDATE(cmdGetSummarizedDataForCompositeEx.m_vMergeTo,lMergeTo);
			SETVARDATE(cmdGetSummarizedDataForCompositeEx.m_vMergeFrom,lMergeFrom);
			strcpy_s(cmdGetSummarizedDataForCompositeEx.m_sSessionID, sSessionID);

			hr = cmdGetSummarizedDataForCompositeEx.Open(&psClientRowset, NULL, true);
			if FAILED(hr) 
				throw "Open";
		}
		// before retrieving next row clear current buffer content
		memset(&cmdGetSummarizedDataForCompositeEx.m_zSegmain, 0, 
						sizeof(cmdGetSummarizedDataForCompositeEx.m_zSegmain));

		memset(&cmdGetSummarizedDataForCompositeEx.m_zSummdata, 0, 
						sizeof(cmdGetSummarizedDataForCompositeEx.m_zSummdata));

		memset(&cmdGetSummarizedDataForCompositeEx.m_zUV, 0, 
						sizeof(cmdGetSummarizedDataForCompositeEx.m_zUV));

		// and get the record
		hr = cmdGetSummarizedDataForCompositeEx.MoveNext();
		if FAILED(hr) 
			throw "MoveNext";

		if (hr == S_OK) // got data - pass them back and exit
		{	
			cmdGetSummarizedDataForCompositeEx.m_cRows++;
   		memcpy(pzSegmain,   &cmdGetSummarizedDataForCompositeEx.m_zSegmain, sizeof(*pzSegmain));
   		memcpy(pzSummdata,  &cmdGetSummarizedDataForCompositeEx.m_zSummdata, sizeof(*pzSummdata));
   		memcpy(pzUV, &cmdGetSummarizedDataForCompositeEx.m_zUV, sizeof(*pzUV));
			pzSummdata->lPerformDate = cmdGetSummarizedDataForCompositeEx.m_vPerformDate.date;
			pzUV->lUVDate = cmdGetSummarizedDataForCompositeEx.m_vPerformDate.date;
   		pzUV->lStreamBeginDate = cmdGetSummarizedDataForCompositeEx.m_vStreamBeginDate.date;
			*pfROR = cmdGetSummarizedDataForCompositeEx.m_fROR;

			// now fill the commonly used (shared) fields
			pzSummdata->iPortfolioID = iID;
			pzUV->iPortfolioID = iID;
			pzSegmain->iOwnerID = iID;
			
			pzSummdata->iID = pzSegmain->iID;
			pzUV->iID = pzSegmain->iID;
			pzSummdata->fWtdFlow = RoundDouble(pzSummdata->fWtdFlow,4);
		}
		else // EOF reached
		{
			pzErr->iSqlError = SQLNOTFOUND;
			cmdGetSummarizedDataForCompositeEx.m_cRows = 0; 
			cmdGetSummarizedDataForCompositeEx.Close();
		}

	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("GetSummarizedDataForCompositeEx",iID,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdGetSummarizedDataForCompositeEx.m_spCommand.p, sErr, hr, 
								"GetSummarizedDataForCompositeEx");
	} // catch
}//GetSummarizedDataForComposite
//****************************************************************

// BuildMergeSData definitions
//****************************************************************

void BuildMergeSData_SQL(char *sSQL)
{
	strcpy_s(sSQL, MAXSQLSIZE,ANY_SQL_000);
	strcat_s(sSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

	strcat_s(sSQL, MAXSQLSIZE,GetSummarizedDataForCompositeEx_SQL_Reset);

	strcat_s(sSQL, MAXSQLSIZE,GetSummarizedDataForCompositeEx_SQL_000);
	/*
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_001);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_002);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004a);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004_01_SUMMDATA);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004c);

	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_000);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_001);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_002);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004a);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004_01_DSUMDATA);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004c);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_004_02_DSUMDATA);
	*/
	/*			
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005a);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005b);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005c);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005d);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005e);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_005f);

	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_000);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_006);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_006a);
	strcat(sSQL, GetSummarizedDataForCompositeEx_SQL_007);
	*/

	strcat_s(sSQL, MAXSQLSIZE,SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
	FILE        *fp;
	fp = fopen("compdataquery.txt", "w");
	fprintf(fp, "%s", sSQL);
	fclose(fp);
#endif
}

void BuildUpdateMergeSData_SQL(char *sSQL)
{
			strcpy_s(sSQL,MAXSQLSIZE, ANY_SQL_000);
			strcat_s(sSQL, MAXSQLSIZE, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005a);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005b);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005c);

			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005d);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005e);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_005f);

			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_000);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_006);

			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_006a);
			strcat_s(sSQL, MAXSQLSIZE, GetSummarizedDataForCompositeEx_SQL_007);

			strcat_s(sSQL, MAXSQLSIZE, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
			FILE        *fp;
			fp = fopen("compupdatequery.txt", "w");
			fprintf(fp, "%s", sSQL);
			fclose(fp);
#endif
}



class CBuildMergeSData : public CQuery
{
public:
// data elements
	char		m_sSessionID[GUID_STR_SIZE+NT];
	int			m_iID;
	VARIANT		m_vMergeFrom;
	VARIANT		m_vMergeTo;

// param binding map
BEGIN_PARAM_MAP(CBuildMergeSData)
   COLUMN_ENTRY(1,	m_sSessionID)  //_004a
   COLUMN_ENTRY(2,	m_sSessionID)  //_004a
   COLUMN_ENTRY(3,	m_vMergeFrom)	//_005a 
   COLUMN_ENTRY(4,	m_vMergeTo)		//_005a

/*
   COLUMN_ENTRY(1,	m_sSessionID)  // Reset

   COLUMN_ENTRY(2,	m_sSessionID)  //_004a
   
   COLUMN_ENTRY(3,	m_vMergeFrom)  //004_01_summdata
   COLUMN_ENTRY(4,	m_vMergeTo)    //004_01_summdata
   
   COLUMN_ENTRY(5,	m_sSessionID)  //004a

   COLUMN_ENTRY(6,	m_vMergeTo)     //004_01_dSumdata
*/
 /* old comment out started here  
   COLUMN_ENTRY(7,	m_vMergeFrom)	//_005a 
   COLUMN_ENTRY(8,	m_vMergeTo)		//_005a

   COLUMN_ENTRY(9,	m_sSessionID)	//_005b
   COLUMN_ENTRY(10,	m_vMergeTo)		//_005b
   COLUMN_ENTRY(11,	m_vMergeFrom)	//_005b

   COLUMN_ENTRY(12,	m_sSessionID)   //_005c
   COLUMN_ENTRY(13,	m_vMergeFrom)   //_005c
   COLUMN_ENTRY(14,	m_vMergeFrom)	//_005e
   COLUMN_ENTRY(15,	m_vMergeTo)		//_005e
   COLUMN_ENTRY(16,	m_sSessionID)	//_005f
   COLUMN_ENTRY(17,	m_vMergeTo)	    //_005f

   COLUMN_ENTRY(18,	m_vMergeTo)		//_006
   COLUMN_ENTRY(19,	m_sSessionID)	//_006
   COLUMN_ENTRY(20,	m_vMergeFrom)	//_006
   COLUMN_ENTRY(21,	m_vMergeTo)		//_006

   COLUMN_ENTRY(22,	m_sSessionID)	//_006a
   COLUMN_ENTRY(23,	m_vMergeTo)		//_006a
   COLUMN_ENTRY(24,	m_vMergeFrom)	//_006a
   COLUMN_ENTRY(25,	m_vMergeFrom)	//_006a
   COLUMN_ENTRY(26,	m_vMergeTo)		//_006a

   COLUMN_ENTRY(27,	m_sSessionID)	//_007
   COLUMN_ENTRY(28,	m_vMergeFrom)	//_007
   COLUMN_ENTRY(29,	m_vMergeTo)		//_007
*/
END_PARAM_MAP()

};



class CBuildUpdateMergeSData : public CQuery
{
public:
// data elements
	char		m_sSessionID[GUID_STR_SIZE+NT];
	int			m_iID;
	VARIANT		m_vMergeFrom;
	VARIANT		m_vMergeTo;

// param binding map
BEGIN_PARAM_MAP(CBuildUpdateMergeSData)

   COLUMN_ENTRY(1,	m_vMergeTo)		//_005a
   COLUMN_ENTRY(2,	m_vMergeFrom)	//_005a 
   COLUMN_ENTRY(3,	m_vMergeTo)		//_005a

   COLUMN_ENTRY(4,	m_sSessionID)	//_005b
   COLUMN_ENTRY(5,	m_vMergeTo)		//_005b
   COLUMN_ENTRY(6,	m_vMergeFrom)	//_005b
   COLUMN_ENTRY(7,	m_sSessionID)   //_005c
   COLUMN_ENTRY(8,	m_vMergeFrom)   //_005c

   COLUMN_ENTRY(9,	m_vMergeTo)		//_005e
   COLUMN_ENTRY(10,	m_vMergeFrom)	//_005e
   COLUMN_ENTRY(11,	m_vMergeTo)		//_005e
   COLUMN_ENTRY(12,	m_sSessionID)	//_005f
   COLUMN_ENTRY(13,	m_vMergeFrom)   //_005f

//   COLUMN_ENTRY(14,	m_vMergeTo)		//_006
   COLUMN_ENTRY(14,	m_sSessionID)	//_006
   COLUMN_ENTRY(15,	m_vMergeFrom)	//_006
   COLUMN_ENTRY(16, m_vMergeTo)		//_006

   COLUMN_ENTRY(17,	m_sSessionID)	//_006a
   COLUMN_ENTRY(18,	m_vMergeTo)		//_006a
   COLUMN_ENTRY(19,	m_vMergeFrom)	//_006a
   COLUMN_ENTRY(20,	m_vMergeFrom)	//_006a
   COLUMN_ENTRY(21,	m_vMergeTo)		//_006a

   COLUMN_ENTRY(22,	m_sSessionID)	//_007
   COLUMN_ENTRY(23,	m_vMergeFrom)	//_007
   COLUMN_ENTRY(24,	m_vMergeTo)		//_007

END_PARAM_MAP()

};



CCommand<CAccessor<CBuildMergeSData>, CRowset > cmdBuildMergeSData;

CCommand<CAccessor<CBuildUpdateMergeSData>, CRowset > cmdBuildUpdateMergeSData;




ERRSTRUCT PrepareBuildUpdateMergeSData(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (cmdBuildUpdateMergeSData.m_bPrepared)
		cmdBuildUpdateMergeSData.Unprepare();
	cmdBuildUpdateMergeSData.m_bPrepared = false;
	cmdBuildUpdateMergeSData.ReleaseCommand();

	if (!cmdBuildUpdateMergeSData.m_bPrepared)
	{
		try 
		{
  			BuildUpdateMergeSData_SQL(cmdBuildUpdateMergeSData.m_sAdjSQL);
			
			hr = cmdBuildUpdateMergeSData.Create(dbSession, 
										cmdBuildUpdateMergeSData.m_sAdjSQL, 
										DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2, 3,4,5,6,7,8,9,10,
				11,12,13,14,15,16, 17,18,19, 20,21,22, 23, 24 };

			DBPARAMBINDINFO	ParamInfo[24] = 
			{
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	1
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	2
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	3
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 9
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 10

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0, // date	from - 11
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 12
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 13


			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 9
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 10
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 11

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 16
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to 17

//			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 18
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 19
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 20
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 - 21

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 22
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  	// date	to	 - 23
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 24
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 25
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 26

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 27
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 28
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0};	// date	to	 - 29
					
			hr = cmdBuildUpdateMergeSData.SetParameterInfo(24, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdBuildUpdateMergeSData.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdBuildUpdateMergeSData.m_vMergeTo.vt = VT_DATE;
			cmdBuildUpdateMergeSData.m_vMergeFrom.vt = VT_DATE;
			cmdBuildUpdateMergeSData.m_cRows = 0;
			cmdBuildUpdateMergeSData.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdBuildUpdateMergeSData.m_spCommand.p, sErr, hr, 
									"cmdBuildUpdateMergeSData");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}




/***/
ERRSTRUCT PrepareBuildMergeSData(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdBuildMergeSData.m_bPrepared)
	{
		try 
		{
  			BuildMergeSData_SQL(cmdBuildMergeSData.m_sAdjSQL);
			
			hr = cmdBuildMergeSData.Create(dbSession, 
										cmdBuildMergeSData.m_sAdjSQL, 
										DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";

			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
/*
			ULONG ulOrds[] = {1,2, 3,4,5,6,7,8,9,10,
							11,12,13,14,15,16,17,18,19, 20,21,22, 23, 24, 25, 26,27,28, 29};
*/
			ULONG ulOrds[] = {1,2, 3,4};//,5,6};
			DBPARAMBINDINFO	ParamInfo[4] = 
			{L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 1
			L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 2
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	3
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 -	4

/*
				
			L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 1

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 2
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	3
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 -	4


			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 5


			L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0};// ,	// date	to- 6
*/
/*
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	7
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from -	8
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 9
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 10

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 11

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 12
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 13

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 14
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 15

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 16
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to 17

			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to - 18
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 19
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 20
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to	 - 21

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 22
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,  	// date	to	 - 23
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 24
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 25
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 26

			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdGetSummarizedDataForCompositeEx.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 27
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from - 28
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0  // date	to	 - 29
			*/ };	
			
/*		
			hr = cmdBuildMergeSData.SetParameterInfo(29, ulOrds, ParamInfo);
*/
 			hr = cmdBuildMergeSData.SetParameterInfo(4, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdBuildMergeSData.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdBuildMergeSData.m_vMergeTo.vt = VT_DATE;
			cmdBuildMergeSData.m_vMergeFrom.vt = VT_DATE;
			cmdBuildMergeSData.m_cRows = 0;
			cmdBuildMergeSData.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors(cmdBuildMergeSData.m_spCommand.p, sErr, hr, 
									"PrepareBuildMergeSData");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL BuildMergeSData(int iID, long lMergeFrom, long lMergeTo, char *sSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "BuildMergeSData", FALSE);
#endif

	*pzErr = PrepareBuildMergeSData();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		strcpy_s(cmdBuildMergeSData.m_sSessionID, sSessionID);
		cmdBuildMergeSData.m_iID = iID;
		SETVARDATE(cmdBuildMergeSData.m_vMergeTo,lMergeTo);
		SETVARDATE(cmdBuildMergeSData.m_vMergeFrom,lMergeFrom);

		hr = cmdBuildMergeSData.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec/Open";

		cmdBuildMergeSData.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("BuildMergeSData",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdBuildMergeSData.m_spCommand.p, sErr, hr, 
								"BuildMergeSData");
	} // catch

/*******   do the updates on the selected merge sdata ***********/
/**** combined into one mergesdata stored proc  
	*pzErr = PrepareBuildUpdateMergeSData();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{	
		strcpy(cmdBuildUpdateMergeSData.m_sSessionID, sSessionID);
		cmdBuildUpdateMergeSData.m_iID = iID;
		cmdBuildUpdateMergeSData.m_vMergeTo.date = lMergeTo;
		cmdBuildUpdateMergeSData.m_vMergeFrom.date = lMergeFrom;

		hr = cmdBuildUpdateMergeSData.Open(NULL, NULL, true);
		if FAILED(hr)
		    throw "Exec/Open";

		cmdBuildUpdateMergeSData.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("cmdBuildUpdateMergeSData",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdBuildUpdateMergeSData.m_spCommand.p, sErr, hr, 
								"cmdBuildUpdateMergeSData");
	} // catch

END combine merge sdata ****/

}//BuildMergeSData
//****************************************************************

//****************************************************************
// CopySummaryData definitions
class CCopySummaryData : public CQuery
{
public:
// data elements
	VARIANT		m_vDate;
	int				m_iPortfolioID;

	char		m_sSrcTable[12];
	char		m_sDestTable[12];

// parameter binding map
BEGIN_PARAM_MAP(CCopySummaryData)
   COLUMN_ENTRY(1,	m_iPortfolioID)
   COLUMN_ENTRY(2,	m_vDate)
END_PARAM_MAP()

DEFINE_COMMAND (CCopySummaryData,	"insert into %DEST_TABLE_NAME%  WITH (ROWLOCK) \n\
									 select * from %SRC_TABLE_NAME% \n\
									 where portfolio_id = ? and perform_date = ?");
};

CCommand<CAccessor<CCopySummaryData> > cmdCopySummaryData;

ERRSTRUCT  PrepareCopySummaryData(char *sSrcTblName, char *sDstTblName)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdCopySummaryData.m_bPrepared || 
		strcmp(cmdCopySummaryData.m_sSrcTable, sSrcTblName)!=0 ||
		strcmp(cmdCopySummaryData.m_sDestTable, sDstTblName)!=0
		)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "CopySummaryData", FALSE);
#endif


		try 
		{
			hr = cmdCopySummaryData.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			// replace abstract tables name by actual ones 
			cmdCopySummaryData.AdjustSQL(sSQL, sDstTblName, sSrcTblName);

			hr = cmdCopySummaryData.Create(dbSession, cmdCopySummaryData.m_sAdjSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			hr = cmdCopySummaryData.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			strcpy_s(cmdCopySummaryData.m_sSrcTable, sSrcTblName);
			strcpy_s(cmdCopySummaryData.m_sDestTable, sDstTblName);

			cmdCopySummaryData.m_vDate.vt = VT_DATE;
			cmdCopySummaryData.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdCopySummaryData.m_spCommand.p, sErr, hr, 
									"PrepareCopySummaryData");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareCopySummaryData

//*****************************************************************
DLLAPI void STDCALL CopySummaryData(int iPortfolioID, int lDate, 
								char *sSrcTblName, char *sDstTblName, ERRSTRUCT *pzErr)

{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, sHoldcash, 0, 0, 0, "CopySummaryData", FALSE);
#endif

	*pzErr = PrepareCopySummaryData(sSrcTblName, sDstTblName);
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		cmdCopySummaryData.m_iPortfolioID = iPortfolioID;
		SETVARDATE(cmdCopySummaryData.m_vDate,lDate);

		hr = cmdCopySummaryData.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdCopySummaryData.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("CopySummaryData",iPortfolioID,lDate,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdCopySummaryData.m_spCommand.p, sErr, hr, 
								"CopySummaryData");
	} // catch
}//CopySummaryData
//****************************************************************


//*****************************************************************
// SummarizeTaxPerf
#define SummarizeTaxPerf_SQL_001 "INSERT INTO TAXPERF WITH (ROWLOCK) \n\
		SELECT smm.owner_id, TTT.* FROM ( \n\
			 SELECT MAX(sm.id) AS id, \n\
			 ? as Perform_date,  \n\
			 SUM(ISNULL(Fedinctax_Wthld,0)) AS Fedinctax_Wthld, \n\
			 SUM(ISNULL(Cum_Fedinctax_Wthld,0)) AS Cum_Fedinctax_Wthld, \n\
       SUM(ISNULL(Wtd_Fedinctax_Wthld,0)) AS Wtd_Fedinctax_Wthld, \n\
       SUM(ISNULL(Fedtax_Rclm,0)) AS Fedtax_Rclm, \n\
       SUM(ISNULL(Cum_Fedtax_Rclm,0)) AS Cum_Fedtax_Rclm, \n\
       SUM(ISNULL(Wtd_Fedtax_Rclm,0)) AS Wtd_Fedtax_Rclm, \n\
       SUM(ISNULL(Fedetax_Inc,0)) AS Fedetax_Inc, \n\
       SUM(ISNULL(Cum_Fedetax_Inc,0)) AS Cum_Fedetax_Inc, \n\
       SUM(ISNULL(Wtd_Fedetax_Inc,0)) AS Wtd_Fedetax_Inc, \n\
       SUM(ISNULL(Fedatax_Inc,0)) AS Fedatax_Inc, \n\
       SUM(ISNULL(Cum_Fedatax_Inc,0)) AS Cum_Fedatax_Inc, \n\
       SUM(ISNULL(Wtd_Fedatax_Inc,0)) AS Wtd_Fedatax_Inc, \n\0"

#define SummarizeTaxPerf_SQL_002 "SUM(ISNULL(Fedetax_Strgl,0)) AS Fedetax_Strgl, \n\
       SUM(ISNULL(Cum_Fedetax_Strgl,0)) AS Cum_Fedetax_Strgl, \n\
       SUM(ISNULL(Wtd_Fedetax_Strgl,0)) AS Wtd_Fedetax_Strgl, \n\
       SUM(ISNULL(Fedetax_Ltrgl,0)) AS Fedetax_Ltrgl, \n\
       SUM(ISNULL(Cum_Fedetax_Ltrgl,0)) AS Cum_Fedetax_Ltrgl, \n\
       SUM(ISNULL(Wtd_Fedetax_Ltrgl,0)) AS Wtd_Fedetax_Ltrgl, \n\
       SUM(ISNULL(Fedetax_Crrgl,0)) AS Fedetax_Crrgl, \n\
       SUM(ISNULL(Cum_Fedetax_Crrgl,0)) AS Cum_Fedetax_Crrgl, \n\
       SUM(ISNULL(Wtd_Fedetax_Crrgl,0)) AS Wtd_Fedetax_Crrgl, \n\
       SUM(ISNULL(Fedatax_Strgl,0)) AS Fedatax_Strgl, \n\
       SUM(ISNULL(Cum_Fedatax_Strgl,0)) AS Cum_Fedatax_Strgl, \n\
       SUM(ISNULL(Wtd_Fedatax_Strgl,0)) AS Wtd_Fedatax_Strgl, \n\
       SUM(ISNULL(Fedatax_Ltrgl,0)) AS Fedatax_Ltrgl, \n\
       SUM(ISNULL(Cum_Fedatax_Ltrgl,0)) AS Cum_Fedatax_Ltrgl, \n\
       SUM(ISNULL(Wtd_Fedatax_Ltrgl,0)) AS Wtd_Fedatax_Ltrgl, \n\
       SUM(ISNULL(Fedatax_Crrgl,0)) AS Fedatax_Crrgl, \n\
       SUM(ISNULL(Cum_Fedatax_Crrgl,0)) AS Cum_Fedatax_Crrgl, \n\
       SUM(ISNULL(Wtd_Fedatax_Crrgl,0)) AS Wtd_Fedatax_Crrgl, \n\0"

#define SummarizeTaxPerf_SQL_003 "SUM(ISNULL(Fedatax_Accr_Inc,0)) AS Fedatax_Accr_Inc, \n\
       SUM(ISNULL(Fedatax_Accr_Div,0)) AS Fedatax_Accr_Div, \n\
       SUM(ISNULL(Fedatax_Inc_Rclm,0)) AS Fedatax_Inc_Rclm, \n\
       SUM(ISNULL(Fedatax_Div_Rclm,0)) AS Fedatax_Div_Rclm, \n\
       SUM(ISNULL(Fedetax_Accr_Inc,0)) AS Fedetax_Accr_Inc, \n\
       SUM(ISNULL(Fedetax_Accr_Div,0)) AS Fedetax_Accr_Div, \n\
       SUM(ISNULL(Fedetax_Inc_Rclm,0)) AS Fedetax_Inc_Rclm, \n\
       SUM(ISNULL(Fedetax_Div_Rclm,0)) AS Fedetax_Div_Rclm, \n\
       1 as Exch_Rate_Base, 1 as Exch_Rate_Sys, \n\0"

#define SummarizeTaxPerf_SQL_004 "SUM(ISNULL(Fedatax_Amort,0)) AS Fedatax_Amort, \n\
       SUM(ISNULL(Cum_Fedatax_Amort,0)) AS Cum_Fedatax_Amort, \n\
       SUM(ISNULL(Wtd_Fedatax_Amort,0)) AS Wtd_Fedatax_Amort, \n\
       SUM(ISNULL(Fedetax_Amort,0)) AS Fedetax_Amort, \n\
       SUM(ISNULL(Cum_Fedetax_Amort,0)) AS Cum_Fedetax_Inc_Amort, \n\
       SUM(ISNULL(Wtd_Fedetax_Amort,0)) AS Wtd_Fedetax_Inc_Amort \n\0"

#define SummarizeTaxPerf_SQL_005 "FROM Merge_CompSegMap sm WITH (NOLOCK)  \n\
			JOIN summdata sd WITH (NOLOCK) ON sd.id = sm.membersegid AND sd.portfolio_id = sm.memberportid \n\
                          AND sd.perform_date > ? AND sd.perform_date <= ? \n\
                          AND (ISNULL(sd.perform_type,'M')<>'D' OR sd.perform_date = ?) \n\
                          AND mkt_val>-1e+308 \n\
      LEFT OUTER JOIN taxperf tp WITH (NOLOCK)  ON tp.portfolio_id = sd.portfolio_id AND tp.id = sd.id \n\
                                 AND tp.perform_date = sd.perform_date \n\
			WHERE sm.SessionID = ? \n\
			GROUP BY segmenttype_id \n\
			) TTT JOIN \n\
			(SELECT DISTINCT id, segmenttype_id, owner_id, SessionID \n\
				FROM Merge_CompSegMap WITH (NOLOCK) \n\
				WHERE SessionID = ?) smm \n\
        ON smm.id = TTT.id \n\0"

class CSummarizeTaxPerf : public CQuery
{
public:
// data elements
	int						m_iID;
	VARIANT				m_vMergeTo;
	VARIANT				m_vMergeFrom;
	char					m_sSessionID[GUID_STR_SIZE+NT];

// parameter binding map
BEGIN_PARAM_MAP(CSummarizeTaxPerf)
   COLUMN_ENTRY(1,	m_vMergeTo)
   COLUMN_ENTRY(2,	m_vMergeFrom)
   COLUMN_ENTRY(3,	m_vMergeTo)
   COLUMN_ENTRY(4,	m_vMergeTo)
   COLUMN_ENTRY(5,	m_sSessionID)
   COLUMN_ENTRY(6,	m_sSessionID)
END_PARAM_MAP()
};

CCommand<CAccessor<CSummarizeTaxPerf> > cmdSummarizeTaxPerf;

ERRSTRUCT  PrepareSummarizeTaxPerf(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSummarizeTaxPerf.m_bPrepared)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "cmdSummarizeTaxPerf", FALSE);
#endif

		try 
		{
			strcpy_s(cmdSummarizeTaxPerf.m_sAdjSQL, ANY_SQL_000);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SummarizeTaxPerf_SQL_001);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SummarizeTaxPerf_SQL_002);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SummarizeTaxPerf_SQL_003);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SummarizeTaxPerf_SQL_004);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SummarizeTaxPerf_SQL_005);
			strcat_s(cmdSummarizeTaxPerf.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
			FILE        *fp;
	    fp = fopen("compquery.txt", "w");
			fprintf(fp, "%s", cmdSummarizeTaxPerf.m_sAdjSQL);
			fclose(fp);
#endif
			
			hr = cmdSummarizeTaxPerf.Create(dbSession, cmdSummarizeTaxPerf.m_sAdjSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2, 3,4,5,6};
			DBPARAMBINDINFO	ParamInfo[6] = 
			{L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeTaxPerf.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeTaxPerf.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			};			

			hr = cmdSummarizeTaxPerf.SetParameterInfo(6, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdSummarizeTaxPerf.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSummarizeTaxPerf.m_vMergeTo.vt = VT_DATE;
			cmdSummarizeTaxPerf.m_vMergeFrom.vt = VT_DATE;
			cmdSummarizeTaxPerf.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSummarizeTaxPerf.m_spCommand.p, sErr, hr, 
									"PrepareSummarizeTaxPerf");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareSummarizeTaxPerf

//*****************************************************************
DLLAPI void STDCALL SummarizeTaxPerf(long iPortfolioID, long lFromDate, long lToDate, 
																char *sSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SummarizeTaxPerf", FALSE);
#endif

	*pzErr = PrepareSummarizeTaxPerf();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		cmdSummarizeTaxPerf.m_iID = iPortfolioID;
		SETVARDATE(cmdSummarizeTaxPerf.m_vMergeTo,lToDate);
		SETVARDATE(cmdSummarizeTaxPerf.m_vMergeFrom,lFromDate);
		strcpy_s(cmdSummarizeTaxPerf.m_sSessionID, sSessionID);

		hr = cmdSummarizeTaxPerf.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdSummarizeTaxPerf.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SummarizeTaxPerf",iPortfolioID,lToDate,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSummarizeTaxPerf.m_spCommand.p, sErr, hr, 
								"SummarizeTaxPerf");
	} // catch
}//SummarizeTaxPerf
//*****************************************************************

//*****************************************************************
// SummarizeMonthsum
#define SummarizeMonthsum_SQL_001 "INSERT INTO MONTHSUM WITH (ROWLOCK) \n\
	SELECT smm.owner_id, TTT.* FROM ( \n\
		SELECT MAX(sm.id) AS id, \n\
			 ? AS Perform_date, \n\
			CASE WHEN MAX(perform_date) = ? THEN 	\n\
				SUM(CASE WHEN mkt_val < -1e+308 THEN 0 ELSE ISNULL(mkt_val,0) END) \n\
			ELSE -1.7e+308 END AS Mkt_val, \n\
       SUM(ISNULL(Book_value, 0)) AS Book_value, \n\
       SUM(ISNULL(Accr_inc, 0)) AS Accr_inc, SUM(ISNULL(Accr_Div, 0)) AS Accr_Div, \n\
       SUM(ISNULL(Inc_rclm, 0)) AS Inc_rclm, SUM(ISNULL(Div_rclm, 0)) AS Div_rclm, \n\
       SUM(ISNULL(Net_Flow, 0)) AS Net_Flow, 0 AS Cum_Flow, \n\
			 SUM(ISNULL(Wtd_flow, 0)) AS Wtd_flow, \n\
       SUM(ISNULL(Purchases, 0)) AS Purchases, SUM(ISNULL(Sales, 0)) AS Sales, \n\
       SUM(ISNULL(Income, 0)) AS Income, 0 AS Cum_income, \n\
			 SUM(ISNULL(Wtd_inc, 0)) AS Wtd_inc, \n\
       SUM(ISNULL(Fees, 0)) AS Fees, 0 AS Cum_fees, \n\
			 SUM(ISNULL(Wtd_Fees, 0)) AS Wtd_Fees,  \n\
       1 AS Exch_rate_base, 'MV' AS Interval_type, 0 AS Days_since_nond, 0 AS Days_since_Last, \n\
       GETDATE() AS Create_Date, GETDATE() AS Change_Date, 'M' AS Perform_type,  \n\
       SUM(ISNULL(PrincipalPayDown, 0)) AS PrincipalPayDown, SUM(ISNULL(Maturity, 0)) AS Maturity, \n\0"

#define SummarizeMonthsum_SQL_002 "SUM(ISNULL(Contributions,0)) - \n\
	 (SELECT ISNULL(SUM(amount),0) FROM bankstat b1 WITH (NOLOCK)  \n\
		WHERE TransactionCode_ID IN (24) \n\
		AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK) \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK) \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND tdate > ? AND tdate <= ? \n\
		AND EXISTS (SELECT * FROM bankstat b2 WITH (NOLOCK)  \n\
			WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
			AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
			AND b2.TransactionCode_ID in (25) )) as Contributions, \n\0"

#define SummarizeMonthsum_SQL_003 "SUM(ISNULL(Withdrawals, 0)) - \n\
		(SELECT ISNULL(SUM(amount),0) FROM bankstat b1 WITH (NOLOCK)  \n\
		WHERE TransactionCode_ID IN (25) \n\
		AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK) \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 WITH (NOLOCK)  \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND tdate > ? AND tdate <= ? \n\
		AND EXISTS (SELECT * FROM bankstat b2 WITH (NOLOCK) \n\
			WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
			AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
			AND b2.TransactionCode_ID IN (24) )) AS Withdrawals, \n\0"

#define SummarizeMonthsum_SQL_004 "SUM(ISNULL(Expenses, 0)) AS Expenses, \n\
	SUM(ISNULL(Receipts, 0)) AS Receipts, \n\
	SUM(ISNULL(IncomeCash, 0)) AS IncomeCash, SUM(ISNULL(PrincipalCash, 0)) AS PrincipalCash, \n\
    SUM(ISNULL(FeesOut, 0)) AS FeesOut, 0 AS Cum_feesOut, \n\
	SUM(ISNULL(Wtd_FeesOut, 0)) AS Wtd_FeesOut,  \n\
	SUM(ISNULL(Transfers, 0)) AS Transfers, \n\
	SUM(ISNULL(TransferIn, 0)) AS TransferIn, SUM(ISNULL(TransferOut, 0)) AS TransferOut, \n\
	0 as Created_By, SUM(ISNULL(EstAnnIncome, 0)) AS EstAnnIncome, SUM(ISNULL(NotionalFlow, 0)) AS NotionalFlow, \n\
SUM(Cons_Fee) AS CONS_Fee, 0.0 cum_cons, SUM(ISNULL(Wtd_Cons,0)) AS Wtd_CONS \n\
  FROM Merge_CompSegMap sm \n\
  JOIN monthsum sd WITH (NOLOCK) ON sd.id = sm.membersegid AND sd.portfolio_id = sm.memberportid \n\
                   AND sd.perform_date = ? \n\
	WHERE sm.SessionID = ? \n\
	GROUP BY SessionID, segmenttype_id \n\
	) TTT JOIN \n\
	(SELECT DISTINCT id, segmenttype_id, owner_id \n\
		FROM Merge_CompSegMap WITH (NOLOCK)  \n\
		WHERE SessionID = ?) smm ON smm.id = TTT.id \n\0"


class CSummarizeMonthsum : public CQuery
{
public:
// data elements
	int						m_iID;
	VARIANT				m_vMergeTo;
	VARIANT				m_vMergeFrom;
	VARIANT				m_vMergeToEnd;
	char					m_sSessionID[GUID_STR_SIZE+NT];

// parameter binding map
BEGIN_PARAM_MAP(CSummarizeMonthsum)
   COLUMN_ENTRY(1,	m_vMergeTo)
   COLUMN_ENTRY(2,	m_vMergeToEnd)

   COLUMN_ENTRY(3,	m_vMergeFrom)
   COLUMN_ENTRY(4,	m_vMergeTo)
   COLUMN_ENTRY(5,	m_vMergeFrom)
   COLUMN_ENTRY(6,	m_vMergeTo)
   COLUMN_ENTRY(7,	m_vMergeTo)
   COLUMN_ENTRY(8,	m_sSessionID)
   COLUMN_ENTRY(9,	m_sSessionID)
END_PARAM_MAP()
};

CCommand<CAccessor<CSummarizeMonthsum> > cmdSummarizeMonthsum;

ERRSTRUCT  PrepareSummarizeMonthsum(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSummarizeMonthsum.m_bPrepared)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "cmdSummarizeMonthsum", FALSE);
#endif

		try 
		{
			strcpy_s(cmdSummarizeMonthsum.m_sAdjSQL, ANY_SQL_000);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SummarizeMonthsum_SQL_001);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SummarizeMonthsum_SQL_002);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SummarizeMonthsum_SQL_003);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SummarizeMonthsum_SQL_004);
			strcat_s(cmdSummarizeMonthsum.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);
			
			hr = cmdSummarizeMonthsum.Create(dbSession, cmdSummarizeMonthsum.m_sAdjSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3,4,5,6,7,8,9};
			DBPARAMBINDINFO	ParamInfo[9] = 
			{L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to (ending)
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date	to
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeMonthsum.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeMonthsum.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			};			

			hr = cmdSummarizeMonthsum.SetParameterInfo(9, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdSummarizeMonthsum.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSummarizeMonthsum.m_vMergeTo.vt = VT_DATE;
			cmdSummarizeMonthsum.m_vMergeFrom.vt = VT_DATE;
			cmdSummarizeMonthsum.m_vMergeToEnd.vt = VT_DATE;
			cmdSummarizeMonthsum.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSummarizeMonthsum.m_spCommand.p, sErr, hr, 
									"PrepareSummarizeMonthsum");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareSummarizeMonthsum

//*****************************************************************
DLLAPI void STDCALL SummarizeMonthsum(long iPortfolioID, long lFromDate, long lToDate, 
																 long lToEndDate, char *sSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SummarizeMonthsum", FALSE);
#endif

	*pzErr = PrepareSummarizeMonthsum();
	if (pzErr->iSqlError != 0)
		return;

	
#ifdef DEBUG
			FILE        *fp;
	    fp = fopen("compmSumquery.txt", "w");
			fprintf(fp, "%s", cmdSummarizeMonthsum.m_sAdjSQL);
			fclose(fp);
#endif



	try 
	{
		cmdSummarizeMonthsum.m_iID = iPortfolioID;
		SETVARDATE(cmdSummarizeMonthsum.m_vMergeTo,lToDate);
		SETVARDATE(cmdSummarizeMonthsum.m_vMergeFrom,lFromDate);
		SETVARDATE(cmdSummarizeMonthsum.m_vMergeToEnd,lToEndDate);
		strcpy_s(cmdSummarizeMonthsum.m_sSessionID, sSessionID);

		hr = cmdSummarizeMonthsum.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdSummarizeMonthsum.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SummarizeMonthsum",iPortfolioID,lToDate,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSummarizeMonthsum.m_spCommand.p, sErr, hr, 
								"SummarizeMonthsum");
	} // catch
}//SummarizeMonthsum
//*****************************************************************


//*****************************************************************
// SummarizeInceptionSummdata
#define SummarizeInceptionSummdata_SQL_001 "INSERT INTO SUMMDATA WITH (ROWLOCK) \n\
	SELECT smm.owner_id, TTT.* FROM ( \n\
		SELECT MAX(sm.id) AS id, \n\
			 ? AS Perform_date, \n\
			SUM(CASE WHEN mkt_val < -1e+308 THEN 0 ELSE ISNULL(mkt_val,0) END) \n\
			AS Mkt_val, \n\
       SUM(ISNULL(Book_value, 0)) AS Book_value, \n\
       SUM(ISNULL(Accr_inc, 0)) AS Accr_inc, SUM(ISNULL(Accr_Div, 0)) AS Accr_Div, \n\
       SUM(ISNULL(Inc_rclm, 0)) AS Inc_rclm, SUM(ISNULL(Div_rclm, 0)) AS Div_rclm, \n\
       SUM(ISNULL(Net_Flow, 0)) AS Net_Flow, 0 AS Cum_Flow, \n\
			 SUM(ISNULL(Wtd_flow, 0)) AS Wtd_flow, \n\
       SUM(ISNULL(Purchases, 0)) AS Purchases, SUM(ISNULL(Sales, 0)) AS Sales, \n\
       SUM(ISNULL(Income, 0)) AS Income, 0 AS Cum_income, \n\
			 SUM(ISNULL(Wtd_inc, 0)) AS Wtd_inc, \n\
       SUM(ISNULL(Fees, 0)) AS Fees, 0 AS Cum_fees, \n\
			 SUM(ISNULL(Wtd_Fees,0)) AS Wtd_Fees, \n\
       1 AS Exch_rate_base, 'MV' AS Interval_type, 0 AS Days_since_nond, 0 AS Days_since_Last, \n\
       GETDATE() AS Create_Date, GETDATE() AS Change_Date, 'I' AS Perform_type, \n\
       SUM(ISNULL(PrincipalPayDown, 0)) AS PrincipalPayDown, SUM(ISNULL(Maturity, 0)) AS Maturity, \n\0"

#define SummarizeInceptionSummdata_SQL_002 "SUM(ISNULL(Contributions,0)) - \n\
	 (SELECT ISNULL(SUM(amount),0) FROM bankstat b1 \n\
		WHERE TransactionCode_ID IN (24) \n\
		AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND tdate = ? \n\
		AND EXISTS (SELECT * FROM bankstat b2 \n\
			WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
			AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
			AND b2.TransactionCode_ID in (25) )) as Contributions, \n\0"

#define SummarizeInceptionSummdata_SQL_003 "SUM(ISNULL(Withdrawals, 0)) - \n\
		(SELECT ISNULL(SUM(amount),0) FROM bankstat b1 \n\
		WHERE TransactionCode_ID IN (25) \n\
		AND b1.id IN (SELECT memberportid FROM Merge_CompSegMap sm2 \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND b1.otheraccountid IN (SELECT memberportid FROM Merge_CompSegMap sm2 \n\
								WHERE sm2.segmenttype_id = sm.segmenttype_id AND sm2.SessionID = sm.SessionID) \n\
		AND tdate = ? \n\
		AND EXISTS (SELECT * FROM bankstat b2 \n\
			WHERE b2.otheraccountid = b1.id AND b2.tdate = b1.tdate \n\
			AND b1.otheraccountid = b2.id AND ABS(b1.amount - b2.amount) < 0.01 \n\
			AND b2.TransactionCode_ID IN (24) )) AS Withdrawals, \n\0"

#define SummarizeInceptionSummdata_SQL_004 "SUM(ISNULL(Expenses, 0)) AS Expenses, \n\
	SUM(ISNULL(Receipts, 0)) AS Receipts, \n\
  SUM(ISNULL(IncomeCash, 0)) AS IncomeCash, SUM(ISNULL(PrincipalCash, 0)) AS PrincipalCash, \n\
  SUM(ISNULL(FeesOut, 0)) AS FeesOut, 0 AS Cum_feesOut, \n\
  SUM(ISNULL(Wtd_FeesOut,0)) AS Wtd_FeesOut, \n\
  SUM(ISNULL(Transfers, 0)) AS Transfers, \n\
  SUM(ISNULL(TransferIn, 0)) AS TransferIn, SUM(ISNULL(TransferOut, 0)) AS TransferOut, \n\
  0 as Created_By, SUM(ISNULL(EstAnnIncome, 0)) AS EstAnnIncome, SUM(ISNULL(NotionalFlow, 0)) AS NotionalFlow \n\
SUM(Cons_Fee) Cons_Fee, 0.0 cum_cons, Sum(ISNULL(Wtd_Cons,0)),  Wtd_Cons FROM Merge_CompSegMap sm \n\
  JOIN summdata sd ON sd.id = sm.membersegid AND sd.portfolio_id = sm.memberportid \n\
                   AND sd.perform_date = ? \n\
	WHERE sm.SessionID = ? \n\0"

#define SummarizeInceptionSummdata_SQL_005 "AND NOT EXISTS \n\
(SELECT * FROM summdata sd_before, Merge_CompSegMap smb \n\
	WHERE sd_before.id = smb.membersegid \n\
	      AND sd_before.portfolio_id = smb.memberportid \n\
              AND sd_before.perform_date < ? \n\
	      AND smb.SessionID = ?) \n\
	GROUP BY SessionID, segmenttype_id \n\
	) TTT JOIN \n\
	(SELECT DISTINCT id, segmenttype_id, owner_id \n\
		FROM Merge_CompSegMap \n\
		WHERE SessionID = ?) smm ON smm.id = TTT.id \n\0"


class CSummarizeInceptionSummdata : public CQuery
{
public:
// data elements
	int					m_iID;
	VARIANT				m_vInceptionDate;
	char				m_sSessionID[GUID_STR_SIZE+NT];

// parameter binding map
BEGIN_PARAM_MAP(CSummarizeInceptionSummdata)
   COLUMN_ENTRY(1,	m_vInceptionDate)
   COLUMN_ENTRY(2,	m_vInceptionDate)

   COLUMN_ENTRY(3,	m_vInceptionDate)
   COLUMN_ENTRY(4,	m_vInceptionDate)
   COLUMN_ENTRY(5,	m_sSessionID)
   COLUMN_ENTRY(6,	m_vInceptionDate)
   COLUMN_ENTRY(7,	m_sSessionID)
   COLUMN_ENTRY(8,	m_sSessionID)
END_PARAM_MAP()
};

CCommand<CAccessor<CSummarizeInceptionSummdata> > cmdSummarizeInceptionSummdata;

ERRSTRUCT  PrepareSummarizeInceptionSummdata(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSummarizeInceptionSummdata.m_bPrepared)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SummarizeInceptionSummdata", FALSE);
#endif

		try 
		{
			strcpy_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, ANY_SQL_000);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SummarizeInceptionSummdata_SQL_001);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SummarizeInceptionSummdata_SQL_002);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SummarizeInceptionSummdata_SQL_003);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SummarizeInceptionSummdata_SQL_004);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SummarizeInceptionSummdata_SQL_005);
			strcat_s(cmdSummarizeInceptionSummdata.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
			FILE        *fp;
			fp = fopen("compquery.txt", "w");
			fprintf(fp, "%s", cmdSummarizeInceptionSummdata.m_sAdjSQL);
			fclose(fp);
#endif
			
			hr = cmdSummarizeInceptionSummdata.Create(dbSession, 
				  cmdSummarizeInceptionSummdata.m_sAdjSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3,4,5,6,7,8};
			DBPARAMBINDINFO	ParamInfo[8] = 
			{L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// inception date
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// inception date
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// inception date
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// inception date
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeMonthsum.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// inception date
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeMonthsum.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdSummarizeMonthsum.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID
			};			

			hr = cmdSummarizeInceptionSummdata.SetParameterInfo(8, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdSummarizeInceptionSummdata.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSummarizeInceptionSummdata.m_vInceptionDate.vt = VT_DATE;
			cmdSummarizeInceptionSummdata.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSummarizeInceptionSummdata.m_spCommand.p, sErr, hr, 
									"PrepareSummarizeInceptionSummdata");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareSummarizeInceptionSummdata

//*****************************************************************
DLLAPI void STDCALL SummarizeInceptionSummdata(long iPortfolioID, long lInceptionDate, 
										 char *sSessionID, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SummarizeInceptionSummdata", FALSE);
#endif

	*pzErr = PrepareSummarizeInceptionSummdata();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		cmdSummarizeInceptionSummdata.m_iID = iPortfolioID;
		SETVARDATE(cmdSummarizeInceptionSummdata.m_vInceptionDate,lInceptionDate);
		strcpy_s(cmdSummarizeInceptionSummdata.m_sSessionID, sSessionID);

		hr = cmdSummarizeInceptionSummdata.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdSummarizeInceptionSummdata.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SummarizeInceptionSummdata",iPortfolioID,lInceptionDate,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSummarizeInceptionSummdata.m_spCommand.p, sErr, hr, 
								"SummarizeInceptionSummdata");
	} // catch
}//SummarizeInceptionSummdata
//*****************************************************************

//*****************************************************************
// SubtractInceptionSummdata
#define SubtractInceptionSummdata_SQL_001 "UPDATE summdata WITH (ROWLOCK) \n\
   SET Change_date = GETDATE(), \n\
   Net_Flow = summdata.Net_Flow - si.Net_Flow, \n\
   Wtd_flow = summdata.Wtd_flow - si.Wtd_flow, \n\
   Purchases = summdata.Purchases - si.Purchases, \n\
   Sales = summdata.Sales - si.Sales, \n\
   Income = summdata.Income - si.Income, \n\
   Wtd_inc = summdata.Wtd_inc - si.Wtd_inc, \n\
   Fees = summdata.Fees - si.Fees, \n\
   Wtd_Fees = summdata.Wtd_Fees - si.Wtd_Fees, \n\
   CONS_Fee = summdata.Cons_Fee - si.Cons_fee,\n\
   Wtd_Cons = summdata.Wtd_Cons - si.Wtd_Cons, \n\
   PrincipalPayDown = summdata.PrincipalPayDown - si.PrincipalPayDown, \n\
   Maturity = summdata.Maturity - si.Maturity, \n\0"

#define SubtractInceptionSummdata_SQL_002 "Contributions = \n\
	  summdata.Contributions - si.Contributions, \n\
   Withdrawals = summdata.Withdrawals - si.Withdrawals, \n\
   Expenses = summdata.Expenses - si.Expenses, \n\
   Receipts = summdata.Receipts - si.Receipts, \n\
   IncomeCash = summdata.IncomeCash - si.IncomeCash, \n\
   PrincipalCash = summdata.PrincipalCash - si.PrincipalCash, \n\
   FeesOut = summdata.FeesOut - si.FeesOut, \n\
   Wtd_FeesOut = summdata.Wtd_FeesOut - si.Wtd_FeesOut, \n\
   Transfers = summdata.Transfers - si.Transfers, \n\
   TransferIn = summdata.TransferIn - si.TransferIn, \n\
   TransferOut = summdata.TransferOut - si.TransferOut, \n\
   EstAnnIncome = summdata.EstAnnIncome - si.EstAnnIncome \n\0"

#define SubtractInceptionSummdata_SQL_003 "FROM summdata, summdata si \n\
   WHERE si.portfolio_id = summdata.portfolio_id AND si.id = summdata.id \n\
   AND si.perform_date = ? AND summdata.portfolio_id = ? \n\
   AND summdata.perform_date = ? \n\0"


class CSubtractInceptionSummdata : public CQuery
{
public:
// data elements
	int					m_iID;
	VARIANT				m_vDateFrom;
	VARIANT				m_vDateTo;

// parameter binding map
BEGIN_PARAM_MAP(CSubtractInceptionSummdata)
   COLUMN_ENTRY(1,	m_vDateFrom)
   COLUMN_ENTRY(2,	m_iID)
   COLUMN_ENTRY(3,	m_vDateTo)
END_PARAM_MAP()
};

CCommand<CAccessor<CSubtractInceptionSummdata> > cmdSubtractInceptionSummdata;

ERRSTRUCT  PrepareSubtractInceptionSummdata(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdSubtractInceptionSummdata.m_bPrepared)
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SubtractInceptionSummdata", FALSE);
#endif

		try 
		{
			strcpy_s(cmdSubtractInceptionSummdata.m_sAdjSQL, ANY_SQL_000);
			strcat_s(cmdSubtractInceptionSummdata.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_UNCOMMITTED);

			strcat_s(cmdSubtractInceptionSummdata.m_sAdjSQL, SubtractInceptionSummdata_SQL_001);
			strcat_s(cmdSubtractInceptionSummdata.m_sAdjSQL, SubtractInceptionSummdata_SQL_002);
			strcat_s(cmdSubtractInceptionSummdata.m_sAdjSQL, SubtractInceptionSummdata_SQL_003);
			strcat_s(cmdSubtractInceptionSummdata.m_sAdjSQL, SQL_SET_TRANS_ISOLATION_LVL_COMMITTED);

#ifdef DEBUG
			FILE        *fp;
			fp = fopen("compquery.txt", "w");
			fprintf(fp, "%s", cmdSubtractInceptionSummdata.m_sAdjSQL);
			fclose(fp);
#endif
			
			hr = cmdSubtractInceptionSummdata.Create(dbSession, 
				  cmdSubtractInceptionSummdata.m_sAdjSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3};
			DBPARAMBINDINFO	ParamInfo[3] = 
			{L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date from
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// compid 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date to
			};			

			hr = cmdSubtractInceptionSummdata.SetParameterInfo(3, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdSubtractInceptionSummdata.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdSubtractInceptionSummdata.m_vDateFrom.vt = VT_DATE;
			cmdSubtractInceptionSummdata.m_vDateTo.vt = VT_DATE;
			cmdSubtractInceptionSummdata.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdSubtractInceptionSummdata.m_spCommand.p, sErr, hr, 
									"PrepareSubtractInceptionSummdata");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareSubtractInceptionSummdata

//*****************************************************************
DLLAPI void STDCALL SubtractInceptionSummdata(long iPortfolioID, long lDateFrom, long lDateTo,
										 ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "SubtractInceptionSummdata", FALSE);
#endif

	*pzErr = PrepareSubtractInceptionSummdata();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		cmdSubtractInceptionSummdata.m_iID = iPortfolioID;
		SETVARDATE(cmdSubtractInceptionSummdata.m_vDateFrom,lDateFrom);
		SETVARDATE(cmdSubtractInceptionSummdata.m_vDateTo,lDateTo);

		hr = cmdSubtractInceptionSummdata.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdSubtractInceptionSummdata.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("SubtractInceptionSummdata",iPortfolioID,lDateFrom,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdSubtractInceptionSummdata.m_spCommand.p, sErr, hr, 
								"SubtractInceptionSummdata");
	} // catch
}//SubtractInceptionSummdata
//*****************************************************************

//****************************************************************
// DeleteMergeSessionData definitions
class CDeleteMergeSessionData : public CQuery
{
public:
// data elements
	char		m_sSessionID[GUID_STR_SIZE+NT];


// parameter binding map
BEGIN_PARAM_MAP(CDeleteMergeSessionData)
   COLUMN_ENTRY(1,	m_sSessionID)
   COLUMN_ENTRY(2,	m_sSessionID)
   COLUMN_ENTRY(3,	m_sSessionID)
   COLUMN_ENTRY(4,	m_sSessionID)
END_PARAM_MAP()

DEFINE_COMMAND (CDeleteMergeSessionData,	"DELETE FROM Merge_SData WITH (ROWLOCK) WHERE SessionID = ? \n\
	DELETE FROM Merge_CompSegMap WITH (ROWLOCK) WHERE SessionID = ?  \n\
	DELETE FROM Merge_Compport WITH (ROWLOCK) WHERE SessionID = ?  \n\
	DELETE FROM Merge_UV WITH (ROWLOCK) WHERE SessionID = ?  \n\
		 ");
};

CCommand<CAccessor<CDeleteMergeSessionData> > cmdDeleteMergeSessionData;

ERRSTRUCT  PrepareDeleteMergeSessionData(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdDeleteMergeSessionData.m_bPrepared) 
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "DeleteMergeSessionData", FALSE);
#endif
 
		try 
		{
			hr = cmdDeleteMergeSessionData.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdDeleteMergeSessionData.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3,4};
			DBPARAMBINDINFO	ParamInfo[4] = 
			{L"DBTYPE_VARCHAR",NULL,sizeof(cmdDeleteMergeSessionData.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 1
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdDeleteMergeSessionData.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 2
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdDeleteMergeSessionData.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 3
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdDeleteMergeSessionData.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID - 4
			};

			hr = cmdDeleteMergeSessionData.SetParameterInfo(4, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdDeleteMergeSessionData.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdDeleteMergeSessionData.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdDeleteMergeSessionData.m_spCommand.p, sErr, hr, 
									"PrepareDeleteMergeSessionData");
			zErr.iSqlError = hr;
		} 
	}

	return zErr;
}//PrepareDeleteMergeSessionData

//*****************************************************************
DLLAPI void STDCALL DeleteMergeSessionData(char *sSessionID, long lPortfolioID, ERRSTRUCT *pzErr)

{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "DeleteMergeSessionData", FALSE);
#endif

	*pzErr = PrepareDeleteMergeSessionData();
	if (pzErr->iSqlError != 0)
		return;
	try 
	{
		strcpy_s(cmdDeleteMergeSessionData.m_sSessionID, sSessionID);
		hr = cmdDeleteMergeSessionData.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdDeleteMergeSessionData.Close();
	} // try
	catch (char* sErr)
	{
		*pzErr = PrintError("DeleteMergeSessionData",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdDeleteMergeSessionData.m_spCommand.p, sErr, hr, 
								"DeleteMergeSessionData");
	} // catch

}//DeleteMergeSessionData
//****************************************************************

//****************************************************************
// UpdateUnitvalueMonthlyIPV definitions
class CUpdateUnitvalueMonthlyIPV : public CQuery
{
public:
// data elements
	char		m_sSessionID[GUID_STR_SIZE+NT];
    VARIANT     m_vDateFrom;
    VARIANT     m_vDateTo;


// parameter binding map
BEGIN_PARAM_MAP(CUpdateUnitvalueMonthlyIPV)
   COLUMN_ENTRY(1,	m_sSessionID)
   COLUMN_ENTRY(2,	m_vDateFrom)
   COLUMN_ENTRY(3,	m_vDateTo)
END_PARAM_MAP()

DEFINE_COMMAND (CUpdateUnitvalueMonthlyIPV,	
    "UPDATE unitvalue WITH (ROWLOCK) SET ror_source='4' \n\
	FROM Merge_CompSegMap \n\
	WHERE SessionID = ? AND unitvalue.id = MemberSegID \n\
	AND uvdate >= ? AND uvdate < ? \n\
	AND ror_source='3' AND DATEPART(dd, DATEADD(dd, 1, uvdate))=1 \n\
	AND EXISTS (SELECT * FROM Portmain P WHERE P.ID = MemberPortID AND PeriodType = 'ptMonthly') \n ");
};

CCommand<CAccessor<CUpdateUnitvalueMonthlyIPV> > cmdUpdateUnitvalueMonthlyIPV;

ERRSTRUCT  PrepareUpdateUnitvalueMonthlyIPV(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdUpdateUnitvalueMonthlyIPV.m_bPrepared) 
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "UpdateUnitvalueMonthlyIPV", FALSE);
#endif


		try 
		{
			hr = cmdUpdateUnitvalueMonthlyIPV.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdUpdateUnitvalueMonthlyIPV.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3};
			DBPARAMBINDINFO	ParamInfo[3] = 
			{L"DBTYPE_VARCHAR",NULL,sizeof(cmdUpdateUnitvalueMonthlyIPV.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID 
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date from
			 L"DBTYPE_DATE",NULL,sizeof(double),DBPARAMFLAGS_ISINPUT,0,0,	// date to
			};

			hr = cmdUpdateUnitvalueMonthlyIPV.SetParameterInfo(3, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdUpdateUnitvalueMonthlyIPV.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdUpdateUnitvalueMonthlyIPV.m_vDateFrom.vt = VT_DATE;
			cmdUpdateUnitvalueMonthlyIPV.m_vDateTo.vt = VT_DATE;
			cmdUpdateUnitvalueMonthlyIPV.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdUpdateUnitvalueMonthlyIPV.m_spCommand.p, sErr, hr, 
									"PrepareUpdateUnitvalueMonthlyIPV");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareUpdateUnitvalueMonthlyIPV

//*****************************************************************
DLLAPI void STDCALL UpdateUnitvalueMonthlyIPV(char *sSessionID, long lDateFrom, long lDateTo, 
										 ERRSTRUCT *pzErr)

{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "UpdateUnitvalueMonthlyIPV", FALSE);
#endif

	*pzErr = PrepareUpdateUnitvalueMonthlyIPV();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		strcpy_s(cmdUpdateUnitvalueMonthlyIPV.m_sSessionID, sSessionID);
		SETVARDATE(cmdUpdateUnitvalueMonthlyIPV.m_vDateFrom,lDateFrom);
		SETVARDATE(cmdUpdateUnitvalueMonthlyIPV.m_vDateTo,lDateTo);

		hr = cmdUpdateUnitvalueMonthlyIPV.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdUpdateUnitvalueMonthlyIPV.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("UpdateUnitvalueMonthlyIPV",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdUpdateUnitvalueMonthlyIPV.m_spCommand.p, sErr, hr, 
								"UpdateUnitvalueMonthlyIPV");
	} // catch
}//UpdateUnitvalueMonthlyIPV
//****************************************************************


//****************************************************************
// DeleteMergeUVGracePeriod definitions
class CDeleteMergeUVGracePeriod : public CQuery
{
public:
// data elements
	char	m_sSessionID[GUID_STR_SIZE+NT];
	int		m_iID;   


// parameter binding map
BEGIN_PARAM_MAP(CDeleteMergeUVGracePeriod)
   COLUMN_ENTRY(1, m_iID)
   COLUMN_ENTRY(2, m_iID)
   COLUMN_ENTRY(3, m_sSessionID)
END_PARAM_MAP()

DEFINE_COMMAND (CDeleteMergeUVGracePeriod,	
   "IF EXISTS (SELECT * FROM \n\
	  portcategory p, userdefcattypes udc, userdefcatnames udn \n\
	  WHERE p.portid = ? AND p.categorytypeid = udc.id \n\
	  AND udc.name IN (SELECT value FROM sysvalues \n\
	  WHERE name = 'GracePeriodCatType') \n\
	  AND p.categorytypeid = udn.categorytypeid \n\
	  AND p.categoryid = udn.id \n\
	  AND udn.name IN (SELECT value FROM sysvalues \n\
	  WHERE name = 'GracePeriodCatName')) \n\
   BEGIN \n\
	  UPDATE Merge_UV WITH (ROWLOCK) \n\
	  SET unitvalue=-999, fudge_factor=1.1 \n\
	  WHERE EXISTS ( SELECT * FROM ( \n\
		 SELECT id, DATEADD(mm,(SELECT CAST(value AS int) \n\
			   FROM sysvalues WHERE name = 'GracePeriodLen'), \n\
			   DateFirstIncluded) AS GracePerodEnd \n\
		 FROM (SELECT id, MIN(DateRangeBegin) AS DateFirstIncluded \n\
			   FROM compport cp WHERE ownerid = ? AND included='Y' \n\
			   AND DateRangeBegin > '12/31/1899'\
			   GROUP BY id ) T \n\
		 ) GPE \n\
		 WHERE GPE.id = Merge_UV.portfolio_id \n\
		 AND Merge_UV.uvdate < GPE.GracePerodEnd AND src = 'E') \n\
		 AND Merge_UV.SessionID = ? \n\
   END ");
};

CCommand<CAccessor<CDeleteMergeUVGracePeriod> > cmdDeleteMergeUVGracePeriod;

ERRSTRUCT  PrepareDeleteMergeUVGracePeriod(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdDeleteMergeUVGracePeriod.m_bPrepared) 
	{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "DeleteMergeUVGracePeriod", FALSE);
#endif


		try 
		{
			hr = cmdDeleteMergeUVGracePeriod.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdDeleteMergeUVGracePeriod.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1,2,3};
			DBPARAMBINDINFO	ParamInfo[3] = 
			{
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// compid 
			 L"DBTYPE_I4",NULL,sizeof(long),DBPARAMFLAGS_ISINPUT,10,0,		// compid 
			 L"DBTYPE_VARCHAR",NULL,sizeof(cmdUpdateUnitvalueMonthlyIPV.m_sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0,	// SessionID 
			};

			hr = cmdDeleteMergeUVGracePeriod.SetParameterInfo(3, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdDeleteMergeUVGracePeriod.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdDeleteMergeUVGracePeriod.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdDeleteMergeUVGracePeriod.m_spCommand.p, sErr, hr, 
									"PrepareDeleteMergeUVGracePeriod");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}//PrepareDeleteMergeUVGracePeriod

//*****************************************************************
DLLAPI void STDCALL DeleteMergeUVGracePeriod(char *sSessionID, int iID, 
										 ERRSTRUCT *pzErr)

{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "DeleteMergeUVGracePeriod", FALSE);
#endif

	*pzErr = PrepareDeleteMergeUVGracePeriod();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		strcpy_s(cmdDeleteMergeUVGracePeriod.m_sSessionID, sSessionID);
		cmdDeleteMergeUVGracePeriod.m_iID = iID;

		hr = cmdDeleteMergeUVGracePeriod.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdDeleteMergeUVGracePeriod.Close();
	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("DeleteMergeUVGracePeriod",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdDeleteMergeUVGracePeriod.m_spCommand.p, sErr, hr, 
								"DeleteMergeUVGracePeriod");
	} // catch
}//DeleteMergeUVGracePeriod
//****************************************************************

//****************************************************************
// InsertMergeCompSegMap definitions
class CInsertMergeCompSegMap : public CQuery
{
public:
// data elements
	MERGE_COMPSEGMAP		m_zMergeCompSegMap;

// parameter binding map
BEGIN_PARAM_MAP(CInsertMergeCompSegMap)
   COLUMN_ENTRY(1,	m_zMergeCompSegMap.sSessionID)
   COLUMN_ENTRY(2,	m_zMergeCompSegMap.lOwner_ID)
   COLUMN_ENTRY(3,	m_zMergeCompSegMap.lID)
   COLUMN_ENTRY(4,	m_zMergeCompSegMap.lMemberPortID)
   COLUMN_ENTRY(5,	m_zMergeCompSegMap.lMemberSegID)
   COLUMN_ENTRY(6,	m_zMergeCompSegMap.lSegmentType_ID)
   COLUMN_ENTRY(7,	m_zMergeCompSegMap.lParentRuleID)
   COLUMN_ENTRY(8,	m_zMergeCompSegMap.lMemberSegType)
   COLUMN_ENTRY(9,	m_zMergeCompSegMap.lLevelNumber)
   COLUMN_ENTRY(10,	m_zMergeCompSegMap.lCatValue)
   COLUMN_ENTRY(11,	m_zMergeCompSegMap.fTaxRate)
   COLUMN_ENTRY(12,	m_zMergeCompSegMap.sName)
END_PARAM_MAP()


DEFINE_COMMAND (CInsertMergeCompSegMap, 	
			"INSERT INTO Merge_CompSegMap ( \n\
				SessionID, Owner_ID, ID, MemberPortID, MemberSegID, \n\
				SegmentType_ID, ParentRuleID, MemberSegType, LevelNumber, \n\
				CatValue, TaxRate, Name \n\
			) VALUES ( \n\
				?, ?, ?, ?, ?, \n\
				?, ?, ?, ?, \n\
				?, ?, ? \n\
			) ");
};

CCommand<CAccessor<CInsertMergeCompSegMap> > cmdInsertMergeCompSegMap;

ERRSTRUCT PrepareInsertMergeCompSegMap(void)
{
	ERRSTRUCT zErr; 
	InitializeErrStruct(&zErr);

	if (!cmdInsertMergeCompSegMap.m_bPrepared) 
	{
		try 
		{
			hr = cmdInsertMergeCompSegMap.GetDefaultCommand((LPCWSTR*)&sSQL);
 			if FAILED(hr) 
				throw "GetSQL";
			
			hr = cmdInsertMergeCompSegMap.Create(dbSession, sSQL, DBGUID_SQL);
 			if FAILED(hr) 
				throw "Create";
		
			// specify param type explicitly 
			// (OLE DB provider for SQL Server can't retrieve param type if subquery is used
			ULONG ulOrds[] = {1};
			DBPARAMBINDINFO	ParamInfo[1] = 
			{L"DBTYPE_VARCHAR",NULL,sizeof(cmdInsertMergeCompSegMap.m_zMergeCompSegMap.sSessionID), 
													DBPARAMFLAGS_ISINPUT,0,0	// SessionID - 1
			};

			hr = cmdInsertMergeCompSegMap.SetParameterInfo(1, ulOrds, ParamInfo);
 			if FAILED(hr) 
				throw "SetParameterInfo";

			hr = cmdInsertMergeCompSegMap.Prepare(0);
 			if FAILED(hr) 
				throw "Prepare";

			cmdInsertMergeCompSegMap.m_bPrepared = true;
		}

		catch (char* sErr)
		{
			dbErr.DisplayAllErrors( cmdInsertMergeCompSegMap.m_spCommand.p, sErr, hr, 
									"PrepareInsertMergeCompSegMap");
			zErr.iSqlError = hr;
		}
	}

	return zErr;
}

DLLAPI void STDCALL InsertMergeCompSegMap(MERGE_COMPSEGMAP zMergeCompSegMap, ERRSTRUCT *pzErr)
{
#ifdef DEBUG
	// trace all calls in debug version
	PrintError("Entering", 0, 0, "", 0, 0, 0, "InsertMergeCompSegMap", FALSE);
#endif

	*pzErr = PrepareInsertMergeCompSegMap();
	if (pzErr->iSqlError != 0)
		return;

	try 
	{
		memcpy(&cmdInsertMergeCompSegMap.m_zMergeCompSegMap, &zMergeCompSegMap, sizeof(zMergeCompSegMap));
		// even with 'memcpy' call above we still need to adjust some fields after that - for dates and rounded values
	
		cmdInsertMergeCompSegMap.m_zMergeCompSegMap.fTaxRate = RoundDouble(zMergeCompSegMap.fTaxRate, 2);
		
		hr = cmdInsertMergeCompSegMap.Open(NULL, NULL, true);
		if FAILED(hr) 
			throw "Exec";

		cmdInsertMergeCompSegMap.Close();

	} // try

	catch (char* sErr)
	{
		*pzErr = PrintError("InsertMergeCompSegMap",0,0,"",0,hr,0,sErr,FALSE);;
		dbErr.DisplayAllErrors(cmdInsertMergeCompSegMap.m_spCommand.p, sErr, hr, 
								"InsertMergeCompSegMap");
	} // catch
}
// InsertMergeCompSegMap 
//****************************************************************


void CloseCompositeMergeIO(void)
{
	cmdInsertMapCompMemTransEx.Close();
	cmdDeleteMapCompMemTransEx.Close();
	cmdSelectSegmainForPortfolio.Close();
	cmdSelectTransFor.Close();
	cmdInsertContacts.Close();
	cmdSelectAllMembersOfAComposite.Close();
	
	cmdBuildMergeCompSegMap.Close();
	cmdBuildMergeCompport.Close();
	cmdBuildMergeSData.Close();
	cmdBuildUpdateMergeSData.Close();
	cmdBuildMergeUV.Close();

	cmdGetSummarizedDataForCompositeEx.Close();
	cmdCopySummaryData.Close();
	cmdDeleteMergeSessionData.Close();
	cmdInsertMergeCompSegMap.Close();
	cmdSummarizeTaxPerf.Close();
	cmdSummarizeMonthsum.Close();
	cmdSummarizeInceptionSummdata.Close();
    cmdSubtractInceptionSummdata.Close();
	cmdUpdateUnitvalueMonthlyIPV.Close();
	cmdDeleteMergeUVGracePeriod.Close();
}

void FreeCompositeMergeIO(void)
{
	CloseCompositeMergeIO();

	if (cmdInsertMapCompMemTransEx.m_bPrepared)
		cmdInsertMapCompMemTransEx.Unprepare();
	cmdInsertMapCompMemTransEx.m_bPrepared = false;
	cmdInsertMapCompMemTransEx.ReleaseCommand();

	if (cmdDeleteMapCompMemTransEx.m_bPrepared)
		cmdDeleteMapCompMemTransEx.Unprepare();
	cmdDeleteMapCompMemTransEx.m_bPrepared = false;
	cmdDeleteMapCompMemTransEx.ReleaseCommand();

	if (cmdSelectSegmainForPortfolio.m_bPrepared)
		cmdSelectSegmainForPortfolio.Unprepare();
	cmdSelectSegmainForPortfolio.m_bPrepared = false;
	cmdSelectSegmainForPortfolio.ReleaseCommand();

	if (cmdSelectTransFor.m_bPrepared)
		cmdSelectTransFor.Unprepare();
	cmdSelectTransFor.m_bPrepared = false;
	cmdSelectTransFor.ReleaseCommand();

	if (cmdInsertContacts.m_bPrepared)
		cmdInsertContacts.Unprepare();
	cmdInsertContacts.m_bPrepared = false;
	cmdInsertContacts.ReleaseCommand();

	if (cmdSelectAllMembersOfAComposite.m_bPrepared)
		cmdSelectAllMembersOfAComposite.Unprepare();
	cmdSelectAllMembersOfAComposite.m_bPrepared = false;
	cmdSelectAllMembersOfAComposite.ReleaseCommand();

	if (cmdBuildMergeCompSegMap.m_bPrepared)
		cmdBuildMergeCompSegMap.Unprepare();
	cmdBuildMergeCompSegMap.m_bPrepared = false;
	cmdBuildMergeCompSegMap.ReleaseCommand();

	if (cmdBuildMergeCompport.m_bPrepared)
		cmdBuildMergeCompport.Unprepare();
	cmdBuildMergeCompport.m_bPrepared = false;
	cmdBuildMergeCompport.ReleaseCommand();

	if (cmdBuildMergeSData.m_bPrepared)
		cmdBuildMergeSData.Unprepare();
	cmdBuildMergeSData.m_bPrepared = false;
	cmdBuildMergeSData.ReleaseCommand();

	if (cmdBuildUpdateMergeSData.m_bPrepared)
		cmdBuildUpdateMergeSData.Unprepare();
	cmdBuildUpdateMergeSData.m_bPrepared = false;
	cmdBuildUpdateMergeSData.ReleaseCommand();
	
	if (cmdBuildMergeUV.m_bPrepared)
		cmdBuildMergeUV.Unprepare();
	cmdBuildMergeUV.m_bPrepared = false;
	cmdBuildMergeUV.ReleaseCommand();

	if (cmdGetSummarizedDataForCompositeEx.m_bPrepared)
		cmdGetSummarizedDataForCompositeEx.Unprepare();
	cmdGetSummarizedDataForCompositeEx.m_bPrepared = false;
	cmdGetSummarizedDataForCompositeEx.ReleaseCommand();

	if (cmdCopySummaryData.m_bPrepared)
		cmdCopySummaryData.Unprepare();
	cmdCopySummaryData.m_bPrepared = false;
	cmdCopySummaryData.ReleaseCommand();

	if (cmdDeleteMergeSessionData.m_bPrepared)
		cmdDeleteMergeSessionData.Unprepare();
	cmdDeleteMergeSessionData.m_bPrepared = false;
	cmdDeleteMergeSessionData.ReleaseCommand();

	if (cmdInsertMergeCompSegMap.m_bPrepared)
		cmdInsertMergeCompSegMap.Unprepare();
	cmdInsertMergeCompSegMap.m_bPrepared = false;
	cmdInsertMergeCompSegMap.ReleaseCommand();

	if (cmdSummarizeTaxPerf.m_bPrepared)
		cmdSummarizeTaxPerf.Unprepare();
	cmdSummarizeTaxPerf.m_bPrepared = false;
	cmdSummarizeTaxPerf.ReleaseCommand();

	if (cmdSummarizeMonthsum.m_bPrepared)
		cmdSummarizeMonthsum.Unprepare();
	cmdSummarizeMonthsum.m_bPrepared = false;
	cmdSummarizeMonthsum.ReleaseCommand();

	if (cmdSummarizeInceptionSummdata.m_bPrepared)
		cmdSummarizeInceptionSummdata.Unprepare();
	cmdSummarizeInceptionSummdata.m_bPrepared = false;
	cmdSummarizeInceptionSummdata.ReleaseCommand();

	if (cmdSubtractInceptionSummdata.m_bPrepared)
		cmdSubtractInceptionSummdata.Unprepare();
	cmdSubtractInceptionSummdata.m_bPrepared = false;
	cmdSubtractInceptionSummdata.ReleaseCommand();

	if (cmdUpdateUnitvalueMonthlyIPV.m_bPrepared)
		cmdUpdateUnitvalueMonthlyIPV.Unprepare();
	cmdUpdateUnitvalueMonthlyIPV.m_bPrepared = false;
	cmdUpdateUnitvalueMonthlyIPV.ReleaseCommand();

	if (cmdDeleteMergeUVGracePeriod.m_bPrepared)
	   cmdDeleteMergeUVGracePeriod.Unprepare();
	cmdDeleteMergeUVGracePeriod.m_bPrepared = false;
	cmdDeleteMergeUVGracePeriod.ReleaseCommand();
}














